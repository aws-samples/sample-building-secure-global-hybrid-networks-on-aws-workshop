AWSTemplateFormatVersion: 2010-09-09
Description: >-
  AWS Cloud WAN Inspection Architecture - Region 1 resources
Transform: 'AWS::LanguageExtensions'

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: EC2 Parameters
        Parameters:
          - InstanceType
          - InstanceDiskSize
          - LatestAmiId

Parameters:
  InstanceType:
    Description: >- 
      EC2 instance type for the workload instance. Default is set to t2.micro
    Default: t2.micro
    Type: String
    ConstraintDescription: Should be a valid EC2 instance type
  InstanceDiskSize:
    Description: EC2 instance disk size in GB. Default is set to 8GB
    Default: 8
    AllowedValues: [8]
    Type: Number
    ConstraintDescription: Should be a valid instance size in GB  
  LatestAmiId:
    Description: Latest EC2 AMI from Systems Manager Parameter Store
    Type: "AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>"
    Default: "/aws/service/ami-amazon-linux-latest/al2023-ami-kernel-default-x86_64"
    ConstraintDescription: Must be a valid EC2 AMI from Systems Manager
  FirewallName:
      Description: Enter the firewall name as seen in the firewall console
      Type: String
      Default: "NetworkFirewall-Region-1"
  FirewallFlowLogGroupName:
      Type: String
      Description:  Name of the CloudWatch log group where your firewall flow logs are stored
      Default: "/network-firewall/flow-logs/us-east-2/"
  FirewallAlertLogGroupName:
      Type: String
      Description:  Name of the CloudWatch log group where your firewall alert logs are stored
      Default: "/network-firewall/alert-logs/us-east-2/"
  ContributorInsightsRuleState:
      Type: String
      Description: Choose to enable or disable the Contributor Insight rules created by this template
      Default: ENABLED
      AllowedValues:
        - ENABLED
        - DISABLED

Resources:
# ---------- Lambda Role ----------
  IamRoleLambdaCFn:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: F3
            reason: "* is required in this use case."
          - id: W11
            reason: "* is required in this use case."
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - lambda.amazonaws.com
          Action:
          - sts:AssumeRole
      Description: Provides permissions for Lambda functions.
      ManagedPolicyArns:
      - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: NetworkManagerAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'networkmanager:ListCoreNetworks'
                  - 'networkmanager:GetCoreNetwork'
                Resource: '*'
        - PolicyName: NetworkFirewallAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'network-firewall:DescribeFirewall'
                Resource: '*'
        - PolicyName: SSMAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'ssm:SendCommand'
                  - 'ssm:GetCommandInvocation'
                Resource: '*'
  # ---------- End of Lambda Role ----------

# ---------- Lambda and Custom Resource to retrieve Core Network ID and ARN ----------
  # Retrieve AWS Cloud WAN Core Network ID using Lambda and Custom Resource:
  # CloudWatch Log Group for DescribeCoreNetworkLambda Function:
  DescribeCoreNetworkLambdaLogGroup:
    Metadata:
      checkov:
        skip:
          - id: "CKV_AWS_158"
            comment: "Ensure that CloudWatch Log Group is encrypted by KMS"
      cfn_nag:
        rules_to_suppress:
          - id: W84
            reason: "CloudWatch Log Group does not require KMS encryption"
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: "/aws/lambda/DescribeCoreNetwork-us-east-2"
      RetentionInDays: 1

  # Lambda Function to retrieve AWS Cloud WAN Core Network ID and ARN:
  DescribeCoreNetworkLambda:
    Metadata:
      checkov:
        skip:
          - id: "CKV_AWS_117"
            comment: "Ensure that AWS Lambda function is configured inside a VPC"
          - id: "CKV_AWS_116"
            comment: "Ensure that AWS Lambda function is configured for a Dead Letter Queue(DLQ)"
          - id: "CKV_AWS_115"
            comment: "Ensure that AWS Lambda function is configured for function-level concurrent execution limit"
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: "Lambda function does not need to be deployed in a VPC"
          - id: W92
            reason: "Lambda function does not need ReservedConcurrentExecutions"
    Type: AWS::Lambda::Function
    DependsOn: DescribeCoreNetworkLambdaLogGroup
    Properties:
      Description: Lambda stack to core network and retrieve core network ID.
      FunctionName: DescribeCoreNetworkLambda-us-east-2
      LoggingConfig:
        LogGroup: !Ref DescribeCoreNetworkLambdaLogGroup 
      Handler: index.handler
      Role: !GetAtt IamRoleLambdaCFn.Arn
      Runtime: python3.12
      Timeout: 900 
      Code:
        ZipFile: |
          import boto3          
          import cfnresponse
          import json
          import logging

          def handler(event, context):
            logger = logging.getLogger()
            logger.setLevel(logging.INFO)
            
            responseData = {}
            responseStatus = cfnresponse.FAILED

            if event["RequestType"] == "Delete":
              responseStatus = cfnresponse.SUCCESS
              cfnresponse.send(event, context, responseStatus, responseData, "CustomResourcePhysicalID")
            if event["RequestType"] == "Create":
              try:
                print(f"Retrieving core network ID:")
                nm_client = boto3.client('networkmanager', region_name='us-east-2')
                core_network = nm_client.list_core_networks()
                core_network_id = core_network['CoreNetworks'][0]['CoreNetworkId']
                core_network_arn = core_network['CoreNetworks'][0]['CoreNetworkArn']
                
                responseData['CoreNetworkId']=core_network_id
                responseData['CoreNetworkArn']=core_network_arn
                responseStatus = cfnresponse.SUCCESS
              except Exception as e:
                logger.info(f"Failed to retrieve the core network id, failure: {e}")
                responseStatus = cfnresponse.FAILED
              
              cfnresponse.send(event, context, responseStatus, responseData, "CustomResourcePhysicalID")
  
  # Custom resource to retrieve AWS Cloud WAN Core Network ID using Lambda function created above:
  RetrieveCoreNetworkIdAndArn:
    Type: Custom::RetrieveCoreNetworkIdAndARN
    Properties: 
      ServiceToken: !GetAtt DescribeCoreNetworkLambda.Arn
      ServiceTimeout: 900
  
  # ---------- End of DescribeCoreNetworkLambda ----------

# ---------- Prod VPC 1 Resources ----------
  # ---------- Prod VPC 1 ----------
  ProdVPC1:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W60
            reason: "VPC Flow logs not used in workshop"
    Type: AWS::EC2::VPC
    Properties: 
      CidrBlock: 10.0.0.0/16
      EnableDnsSupport: true
      EnableDnsHostnames: true
      Tags: 
        - Key: Name
          Value: "prod-vpc1-us-east-2"
  
  # ---------- Prod VPC 1 Subnets ----------
  # CWAN Subnets:
  ProdVPC1CWANSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId:
        Ref: ProdVPC1
      CidrBlock: 10.0.0.0/28
      AvailabilityZone: !Select
        - 0
        - Fn::GetAZs: !Ref AWS::Region
      MapPublicIpOnLaunch: false
      Tags:
        - Key: Name
          Value: "prod-vpc1-cwan-subnet1-us-east-2"

  ProdVPC1CWANSubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref ProdVPC1
      CidrBlock: 10.0.0.16/28
      AvailabilityZone: !Select [1, Fn::GetAZs: !Ref AWS::Region]
      MapPublicIpOnLaunch: false
      Tags:
        - Key: Name
          Value: "prod-vpc1-cwan-subnet2-us-east-2"  
  
  # Endpoint Subnets:
  ProdVPC1EndpointSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref ProdVPC1
      CidrBlock: 10.0.0.32/28
      AvailabilityZone: !Select [0, Fn::GetAZs: !Ref AWS::Region]
      MapPublicIpOnLaunch: false
      Tags:
        - Key: Name
          Value: "prod-vpc1-endpoint-subnet1-us-east-2"

  ProdVPC1EndpointSubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref ProdVPC1
      CidrBlock: 10.0.0.48/28
      AvailabilityZone: !Select [1, Fn::GetAZs: !Ref AWS::Region]
      MapPublicIpOnLaunch: false
      Tags:
        - Key: Name
          Value: "prod-vpc1-endpoint-subnet2-us-east-2"  

  # Workload Subnets:
  ProdVPC1WorkloadSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref ProdVPC1
      CidrBlock: 10.0.1.0/24
      AvailabilityZone: !Select [0, Fn::GetAZs: !Ref AWS::Region]
      MapPublicIpOnLaunch: false
      Tags:
        - Key: Name
          Value: "prod-vpc1-workload-subnet1-us-east-2"

  ProdVPC1WorkloadSubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref ProdVPC1
      CidrBlock: 10.0.2.0/24
      AvailabilityZone: !Select [1, Fn::GetAZs: !Ref AWS::Region]
      MapPublicIpOnLaunch: false
      Tags:
        - Key: Name
          Value: "prod-vpc1-workload-subnet2-us-east-2"

  # ---------- Prod VPC 1 Route Tables and Subnet Associations ----------
  # CWAN Route Tables:
  ProdVPC1CWANRTB1:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref ProdVPC1
      Tags:
        - Key: Name
          Value: "prod-vpc1-cwan-rtb1-us-east-2"
  
  ProdVPC1CWANRTB2:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref ProdVPC1
      Tags:
        - Key: Name
          Value: "prod-vpc1-cwan-rtb2-us-east-2"  

  # CWAN Route Tables Subnet Associations:
  ProdVPC1CWANRTB1Association:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref ProdVPC1CWANRTB1
      SubnetId: !Ref ProdVPC1CWANSubnet1
  
  ProdVPC1CWANRTB2Association:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref ProdVPC1CWANRTB2
      SubnetId: !Ref ProdVPC1CWANSubnet2  

  # Endpoint Route Tables:
  ProdVPC1EndpointRTB1:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref ProdVPC1
      Tags:
        - Key: Name
          Value: "prod-vpc1-endpoint-rtb1-us-east-2"
  
  ProdVPC1EndpointRTB2:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref ProdVPC1
      Tags:
        - Key: Name
          Value: "prod-vpc1-endpoint-rtb2-us-east-2"  

  # Endpoint Route Tables Subnet Associations:
  ProdVPC1EndpointRTB1Association:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref ProdVPC1EndpointRTB1
      SubnetId: !Ref ProdVPC1EndpointSubnet1
  
  ProdVPC1EndpointRTB2Association:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref ProdVPC1EndpointRTB2
      SubnetId: !Ref ProdVPC1EndpointSubnet2

  # Workload Route Tables:  
  ProdVPC1WorkloadRTB1:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref ProdVPC1
      Tags:
        - Key: Name
          Value: "prod-vpc1-workload-rtb1-us-east-2"
  
  ProdVPC1WorkloadRTB2:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref ProdVPC1
      Tags:
        - Key: Name
          Value: "prod-vpc1-workload-rtb2-us-east-2"
  
  # Workload Route Tables Subnet Associations:
  ProdVPC1WorkloadRTB1Association:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref ProdVPC1WorkloadRTB1
      SubnetId: !Ref ProdVPC1WorkloadSubnet1
  
  ProdVPC1WorkloadRTB2Association:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref ProdVPC1WorkloadRTB2
      SubnetId: !Ref ProdVPC1WorkloadSubnet2

  # ---------- AWS Cloud WAN attachment and default route----------
  # Create Prod VPC 1 Cloud WAN Attachment:
  ProdVPC1CWANAttachment:
    Type: AWS::NetworkManager::VpcAttachment
    Properties:
      CoreNetworkId: !GetAtt RetrieveCoreNetworkIdAndArn.CoreNetworkId
      VpcArn: !Sub "arn:aws:ec2:${AWS::Region}:${AWS::AccountId}:vpc/${ProdVPC1}"
      SubnetArns:
        - !Sub "arn:aws:ec2:${AWS::Region}:${AWS::AccountId}:subnet/${ProdVPC1CWANSubnet1}"
        - !Sub "arn:aws:ec2:${AWS::Region}:${AWS::AccountId}:subnet/${ProdVPC1CWANSubnet2}"
      Tags:
        - Key: Name
          Value: "prod-vpc1-attachment-us-east-2"
        - Key: domain
          Value: Production

  # Create default route in Workload route tables with Core Network ARN has the next hop:
  ProdVPC1WorkloadRTB1DefaultRoute:
    DependsOn:
      - ProdVPC1CWANAttachment
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref ProdVPC1WorkloadRTB1
      DestinationCidrBlock: 0.0.0.0/0
      CoreNetworkArn: !GetAtt RetrieveCoreNetworkIdAndArn.CoreNetworkArn

  ProdVPC1WorkloadRTB2DefaultRoute:
    DependsOn: [ProdVPC1CWANAttachment]
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref ProdVPC1WorkloadRTB2
      DestinationCidrBlock: 0.0.0.0/0
      CoreNetworkArn: !GetAtt RetrieveCoreNetworkIdAndArn.CoreNetworkArn

  # ---------- Create Security Groups ----------
  # Create Workload SG:
  ProdVPC1WorkloadSecurityGroup:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W40
            reason: "Security Groups egress with an IpProtocol of -1 is required"
          - id: W5
            reason: "Security Groups found with cidr open to world on egress is required"
          - id: W42
            reason: "Security Groups ingress with an ipProtocol of -1 is required"
          - id: W9
            reason: "Security Groups found with ingress cidr that is not /32 is required"
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Prod VPC Workload EC2 Instance Security Group
      VpcId: !Ref ProdVPC1
      SecurityGroupIngress:
        - CidrIp: 10.0.0.0/8
          Description: Allowing inbound connection from 10.0.0.0/8 CIDR.
          IpProtocol: "-1"
          FromPort: -1
          ToPort: -1             
        - CidrIp: 172.20.0.0/16
          Description: Allowing inbound connection from 172.20.0.0/16 CIDR.
          IpProtocol: "-1"
          FromPort: -1
          ToPort: -1
      SecurityGroupEgress:
        - CidrIp: 0.0.0.0/0
          Description: Allowing outbound connection to 0.0.0.0/0 CIDR.
          IpProtocol: "-1"
          FromPort: -1
          ToPort: -1

  # Create EC2 instance connect endpoint SG:
  ProdVPC1EndpointSecurityGroup:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W40
            reason: "Security Groups egress with an IpProtocol of -1 is required"
          - id: W5
            reason: "Security Groups found with cidr open to world on egress is required"
          - id: W42
            reason: "Security Groups ingress with an ipProtocol of -1 is required"
          - id: W9
            reason: "Security Groups found with ingress cidr that is not /32 is required"
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Prod VPC 1 Endpoint Security Group
      VpcId: !Ref ProdVPC1

  ProdVPC1WorkloadSecurityGroupIngressEIC:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref ProdVPC1WorkloadSecurityGroup
      Description: Allowing inbound connenciton from EC2 Instance Connect (EIC).
      IpProtocol: tcp
      FromPort: 22
      ToPort: 22
      SourceSecurityGroupId: !Ref ProdVPC1EndpointSecurityGroup
  
  ProdVPC1EndpointSecurityGroupEgressEIC:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      GroupId: !Ref ProdVPC1EndpointSecurityGroup
      Description: Allowing outbound connection to EC2 Instance Connect (EIC).
      IpProtocol: tcp
      FromPort: 22
      ToPort: 22
      DestinationSecurityGroupId: !Ref ProdVPC1WorkloadSecurityGroup

  # ---------- EC2 Instance Connect Endpoint ----------
  ProdVPC1EICEndpoint:
    Type: AWS::EC2::InstanceConnectEndpoint
    Properties:
      PreserveClientIp: false
      SecurityGroupIds: 
        - !Ref ProdVPC1EndpointSecurityGroup
      SubnetId: !Ref ProdVPC1EndpointSubnet1
      Tags: 
        - Key: Name
          Value: "prod-vpc1-eic-us-east-2"

  SSMEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      VpcId: !Ref ProdVPC1
      ServiceName: !Sub com.amazonaws.${AWS::Region}.ssm
      VpcEndpointType: Interface
      SubnetIds:
        - !Ref ProdVPC1EndpointSubnet1
        - !Ref ProdVPC1EndpointSubnet2
      SecurityGroupIds:
        - !Ref ProdVPC1EndpointSecurityGroup
      PrivateDnsEnabled: true

  SSMMessagesEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      VpcId: !Ref ProdVPC1
      ServiceName: !Sub com.amazonaws.${AWS::Region}.ssmmessages
      VpcEndpointType: Interface
      SubnetIds:
        - !Ref ProdVPC1EndpointSubnet1
        - !Ref ProdVPC1EndpointSubnet2
      SecurityGroupIds:
        - !Ref ProdVPC1EndpointSecurityGroup
      PrivateDnsEnabled: true

  EC2MessagesEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      VpcId: !Ref ProdVPC1
      ServiceName: !Sub com.amazonaws.${AWS::Region}.ec2messages
      VpcEndpointType: Interface
      SubnetIds:
        - !Ref ProdVPC1EndpointSubnet1
        - !Ref ProdVPC1EndpointSubnet2
      SecurityGroupIds:
        - !Ref ProdVPC1EndpointSecurityGroup
      PrivateDnsEnabled: true

  ProdVPC1EndpointSecurityGroup:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W40
            reason: "Security Groups egress with an IpProtocol of -1 is required"
          - id: W5
            reason: "Security Groups found with cidr open to world on egress is required"
          - id: W42
            reason: "Security Groups ingress with an ipProtocol of -1 is required"
          - id: W9
            reason: "Security Groups found with ingress cidr that is not /32 is required"
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Prod VPC 1 Endpoint Security Group
      VpcId: !Ref ProdVPC1
      SecurityGroupIngress:
        - Description: Allow HTTPS inbound for SSM
          IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 10.0.0.0/16  # PROD VPC CIDR
      Tags:
        - Key: Name
          Value: "prod-vpc-endpoint-sg-us-east-2"

  # ---------- Create Worload EC2 Intances ----------
  # Workoad Instance 1:
  ProdVPC1WorkloadInstance1:
    Type: AWS::EC2::Instance
    Properties:
      PrivateIpAddress: 10.0.1.100
      ImageId: !Ref LatestAmiId
      InstanceType: !Ref InstanceType      
      SubnetId: !Ref ProdVPC1WorkloadSubnet1
      IamInstanceProfile: !Ref SSMInstanceProfile
      SecurityGroupIds:
        - !Ref ProdVPC1WorkloadSecurityGroup
      Tags:
        - Key: Name
          Value: "PROD - Private Internal API"
      UserData:
        Fn::Base64: |
          #!/bin/bash -ex
          # Install packages:
          sudo yum update -y
          sudo yum install -y jq httpd htop mod_ssl nc php php-common php-fpm

          # Enable and start services
          sudo systemctl enable httpd php-fpm
          sudo systemctl start httpd php-fpm

          # Configure hostname:
          sudo hostnamectl set-hostname customerdata.internalapi.com

          # Define variables:
          curl --silent http://169.254.169.254/latest/dynamic/instance-identity/document > /home/ec2-user/iid
          export instance_interface=$(curl --silent http://169.254.169.254/latest/meta-data/network/interfaces/macs/)
          export instance_vpcid=$(curl --silent http://169.254.169.254/latest/meta-data/network/interfaces/macs/$instance_interface/vpc-id)
          export instance_az=$(cat /home/ec2-user/iid |grep 'availability' | awk -F': ' '{print $2}' | awk -F',' '{print $1}')
          export instance_ip=$(cat /home/ec2-user/iid |grep 'privateIp' | awk -F': ' '{print $2}' | awk -F',' '{print $1}' | awk -F'"' '{print$2}')
          export instance_region=$(cat /home/ec2-user/iid |grep 'region' | awk -F': ' '{print $2}' | awk -F',' '{print $1}' | awk -F'"' '{print$2}')

          # Generate self-signed certificate
          mkdir -p /etc/httpd/ssl
          openssl req -new -newkey rsa:2048 -days 365 -nodes -x509 \
              -keyout /etc/httpd/ssl/apache-selfsigned.key \
              -out /etc/httpd/ssl/apache-selfsigned.crt \
              -subj "/C=US/ST=State/L=City/O=Organization/OU=Department/CN=customerdata.internalapi.com"

          # Configure SSL
          cat <<EOL > /etc/httpd/conf.d/ssl.conf
          Listen 443
          <VirtualHost *:443>
              ServerName customerdata.internalapi.com
              ServerAdmin webmaster@localhost
              DocumentRoot /var/www/html
              SSLEngine on
              SSLCertificateFile /etc/httpd/ssl/apache-selfsigned.crt
              SSLCertificateKeyFile /etc/httpd/ssl/apache-selfsigned.key
              <Directory "/var/www/html">
                  AllowOverride All
              </Directory>
              ErrorLog logs/ssl_error_log
              CustomLog logs/ssl_access_log common
          </VirtualHost>
          EOL

          # Add index.html with hard-coded customer data
          cat <<EOT > /var/www/html/index.html
          {
              "Customer ID": "CUS12345",
              "Customer Subscription Level": "Platinum",
              "Customer Phone Number": "555-123-4567",
              "Customer DOB": "03-15-1985",
              "Customer Notes": "VIP customer - Priority Support Required"
          }
          EOT

          sudo tee /etc/httpd/conf.d/php.conf << 'EOF'
          <FilesMatch \.php$>
              SetHandler "proxy:unix:/run/php-fpm/www.sock|fcgi://localhost"
          </FilesMatch>
          AddType application/x-httpd-php .php
          EOF


          # Configure PHP-FPM pool
          sudo tee /etc/php-fpm.d/www.conf << 'EOF'
          [www]
          user = apache
          group = apache
          listen = /run/php-fpm/www.sock
          listen.owner = apache
          listen.group = apache
          pm = dynamic
          pm.max_children = 50
          pm.start_servers = 5
          pm.min_spare_servers = 5
          pm.max_spare_servers = 35
          EOF

          # Configure handlers in Apache
          sudo tee /etc/httpd/conf.d/cgi-handlers.conf << 'EOF'
          <Directory "/var/www/html">
              Options +ExecCGI
              AddHandler cgi-script .cgi
              AddHandler application/x-httpd-php .php
              <FilesMatch "\.php$">
                  SetHandler "proxy:unix:/run/php-fpm/www.sock|fcgi://localhost"
              </FilesMatch>
          </Directory>
          LoadModule proxy_module modules/mod_proxy.so
          LoadModule proxy_fcgi_module modules/mod_proxy_fcgi.so
          EOF




          # Create directories
          sudo mkdir -p /var/www/html/api

          # Create test endpoints
          sudo tee /var/www/html/api/response.php << 'EOF'
          <?php
          header('Content-Type: application/json');
          echo json_encode(['status' => 'ok']);
          ?>
          EOF

          sudo chown -R apache:apache /var/www/html
          sudo chmod 755 /var/www/html
          sudo chmod 755 /var/www/html/api


          sudo tee /var/www/html/system_mgr.cgi << 'EOF'
          #!/bin/bash
          echo "Content-type: text/plain"
          echo ""
          echo "System Manager Response"
          EOF

          # Set permissions
          sudo chmod 755 /var/www/html/system_mgr.cgi
          sudo chmod 644 /var/www/html/api/response.php
          sudo chown apache:apache /var/www/html/api/response.php
          sudo chown apache:apache /var/www/html/system_mgr.cgi

          # Create malicious PowerShell script endpoints
          sudo tee /var/www/html/secrets.ps1 << 'EOF'
          Function Invoke-SecretsDump {
              Write-Host "Initiating DC Sync operation..."
              $targetDC = "DC01.domain.local"
              
              # This matches the rule pattern "lsadump::dcsync"
              Write-Host "lsadump::dcsync /domain:domain.local /all /csv"
              
              # Additional malicious-looking content
              $methods = @(
                  "lsadump::sam",
                  "lsadump::secrets",
                  "lsadump::cache"
              )
              
              foreach ($method in $methods) {
                  Write-Host "Executing: $method"
              }
          }
          EOF

          sudo tee /var/www/html/kirby.ps1 << 'EOF'
          Function Invoke-Kirby{
              # These match the rule patterns "|24 78|" and "|24 73 6e|" (which are hex for $x and $sn)
              $x = "KIRBY_IMPLANT_ID"
              $sn = "KIRBY_SESSION_ID"
              
              # Additional malicious-looking content
              $domains = Get-ADForest | Select-Object -ExpandProperty Domains
              $dcs = foreach($domain in $domains) {
                  Get-ADDomainController -Filter * -Server $domain
              }
              
              # Enumerate domain admins
              $admins = Get-ADGroupMember "Domain Admins" -Recursive
              
              # Collect system info
              $sysinfo = Get-WmiObject Win32_ComputerSystem
              $osinfo = Get-WmiObject Win32_OperatingSystem
          }
          EOF

          sudo tee /var/www/html/psmap.ps1 << 'EOF'
          Function PsMapExec{
              [System.Text.Encoding]::ASCII.GetString([System.Convert]::FromBase64String("BASE64_ENCODED_CONTENT"))
          }
          EOF

          # Set permissions for the new files
          sudo chmod 644 /var/www/html/secrets.ps1
          sudo chmod 644 /var/www/html/psmap.ps1
          sudo chmod 644 /var/www/html/kirby.ps1
          sudo chown apache:apache /var/www/html/secrets.ps1
          sudo chown apache:apache /var/www/html/psmap.ps1
          sudo chown apache:apache /var/www/html/kirby.ps1

          # Create malicious PowerShell script endpoints
          sudo tee /var/www/html/script.ps1 << 'EOF'
          <?php
          $requestBody = file_get_contents('php://input');

          if (strpos($requestBody, 'AntiVirusProduct') !== false) {
              echo 'Get-CimInstance -ClassName "AntiVirusProduct"';
          } elseif (strpos($requestBody, 'NetFirewallProfile') !== false) {
              echo 'Set-NetFirewallProfile -Profile Domain,Public,Private -Enabled False';
          } elseif (strpos($requestBody, '[Byte[]]') !== false) {
              echo '[Byte[]]$var = 0x48,0x65,0x6c,0x6c,0x6f=(1)';
          } elseif (strpos($requestBody, 'PasswordVault') !== false) {
              echo '[Windows.Security.Credentials.PasswordVault].GetMethod("RetrievePassword").Invoke()';
          } else {
              header("HTTP/1.0 404 Not Found");
              echo "404 Not Found";
          }
          ?>
          EOF

          # Create malicious PowerShell enumeration script
          sudo tee /var/www/html/enum.ps1 << 'EOF'
          Get-CimInstance -ClassName "AntiVirusProduct"
          Get-Process | Where-Object {$_.ProcessName -like "*defender*"}
          Get-MpComputerStatus
          Get-NetFirewallProfile
          EOF

          # Create malicious PowerShell firewall disable script
          sudo tee /var/www/html/disable_security.ps1 << 'EOF'
          Set-NetFirewallProfile -Profile Domain,Public,Private -Enabled False
          Set-MpPreference -DisableRealtimeMonitoring $true
          EOF

          # Create obfuscated PowerShell script
          sudo tee /var/www/html/obfuscated.ps1 << 'EOF'
          [Byte[]]$var = 0x48,0x65,0x6c,0x6c,0x6f=(1)
          [System.Text.Encoding]::ASCII.GetString([System.Convert]::FromBase64String("Base64EncodedPayload"))
          EOF

          # Create credential access script
          sudo tee /var/www/html/creds.ps1 << 'EOF'
          [Windows.Security.Credentials.PasswordVault].GetMethod("RetrievePassword").Invoke()
          Get-ChildItem -Path "HKLM:\SECURITY\Policy\Secrets"
          EOF

          # Keep the existing malicious script endpoints
          sudo tee /var/www/html/secrets.ps1 << 'EOF'
          Function Invoke-SecretsDump {
              lsadump::dcsync
              # Rest of script content
          }
          EOF

          sudo tee /var/www/html/kirby.ps1 << 'EOF'
          Function Invoke-Kirby{
              $x="test"
              $sn="test"
              # Rest of script content
          }
          EOF

          # Create the administrator directory first
          sudo mkdir -p /var/www/html/administrator

          sudo tee /var/www/html/administrator/index.php << 'EOF'
          <?php
          header('Content-Type: application/json');
          if ($_SERVER['REQUEST_METHOD'] === 'POST') {
              $input = file_get_contents('php://input');
              echo json_encode([
                  'received_data' => urldecode($input),
                  'raw_data' => $input,
                  'post_data' => $_POST
              ]);
          } else {
              echo json_encode(['error' => 'Invalid request method']);
          }
          EOF

          sudo chmod 644 /var/www/html/administrator/index.php
          sudo chown apache:apache /var/www/html/administrator/index.php

          sudo mkdir -p /var/www/html/admin
          sudo tee /var/www/html/admin/config.php << 'EOF'
          <?php
          error_reporting(E_ALL);
          ini_set('display_errors', 1);
          header('Content-Type: application/json');

          $response = [
              'received' => true,
              'get_params' => $_GET,
              'raw_query' => $_SERVER['QUERY_STRING']
          ];

          if (isset($_GET['password']) && is_array($_GET['password']) && isset($_GET['password'][0]) && isset($_GET['username'])) {
              $response['vulnerability_test'] = 'Potential FreePBX Authentication Bypass attempt detected';
          }

          echo json_encode($response);
          EOF

          sudo chmod 644 /var/www/html/admin/config.php
          sudo chown apache:apache /var/www/html/admin/config.php
          if command -v semanage >/dev/null 2>&1; then
              # Allow Apache to handle PHP URLs with unusual patterns
              sudo setsebool -P httpd_read_user_content 1
              sudo setsebool -P httpd_enable_cgi 1
              sudo setsebool -P httpd_can_network_relay 1
              
              # Set context for the admin directory
              sudo semanage fcontext -a -t httpd_sys_rw_content_t "/var/www/html/admin(/.*)?"
              sudo restorecon -Rv /var/www/html/admin
              
              # Allow Apache to handle unusual URL patterns
              sudo setsebool -P httpd_setrlimit 1
              sudo setsebool -P httpd_anon_write 1
              
              # Apply the changes
              sudo restorecon -Rv /var/www/html
          fi

          # Set permissions for all script files
          sudo chmod 644 /var/www/html/*.ps1
          sudo chown apache:apache /var/www/html/*.ps1

          # Set proper permissions for all files
          sudo find /var/www/html -type f -exec chmod 644 {} \;
          sudo find /var/www/html -type f -name "*.cgi" -exec chmod 755 {} \;
          sudo find /var/www/html -type f -exec chown apache:apache {} \;

          # Install PHP modules that might be needed
          sudo yum install -y php-mbstring php-xml php-json

          # Restart services to apply all changes
          sudo systemctl restart php-fpm
          sudo systemctl restart httpd

          # Verify PHP processing
          sudo tee /var/www/html/phpinfo.php << 'EOF'
          <?php phpinfo(); ?>
          EOF

          # Set SELinux contexts if SELinux is enabled
          if command -v semanage >/dev/null 2>&1; then
              sudo semanage fcontext -a -t httpd_sys_content_t "/var/www/html(/.*)?"
              sudo restorecon -Rv /var/www/html
              sudo setsebool -P httpd_can_network_connect on
              sudo setsebool -P httpd_can_network_connect_db on
              sudo setsebool -P httpd_unified on
              sudo setsebool -P httpd_execmem on
              sudo semanage fcontext -a -t httpd_var_run_t "/run/php-fpm(/.*)?"
              sudo restorecon -Rv /run/php-fpm
          fi

          # Restart Apache to apply changes
          sudo systemctl restart httpd

          # Install cronie
          sudo dnf install cronie -y

          # Start and enable crond service
          sudo systemctl start crond
          sudo systemctl enable crond

          # Create a script for DNS cache flush
          cat << 'EOF' | sudo tee /usr/local/bin/flush-dns-cache.sh
          #!/bin/bash
          systemctl restart systemd-resolved
          EOF

          # Make the script executable
          sudo chmod +x /usr/local/bin/flush-dns-cache.sh

          # Add cron job to run every minute
          echo "* * * * * root /usr/local/bin/flush-dns-cache.sh" | sudo tee /etc/cron.d/flush-dns-cache

          # Set proper permissions for the cron job file
          sudo chmod 644 /etc/cron.d/flush-dns-cache


  # Workoad Instance 2:
  ProdVPC1WorkloadInstance2:
    Type: AWS::EC2::Instance
    Properties:
      PrivateIpAddress: 10.0.2.50
      ImageId: !Ref LatestAmiId
      InstanceType: !Ref InstanceType
      IamInstanceProfile: !Ref SSMInstanceProfile      
      SubnetId: !Ref ProdVPC1WorkloadSubnet2
      SecurityGroupIds:
        - !Ref ProdVPC1WorkloadSecurityGroup
      Tags:
        - Key: Name
          Value: "PROD - Customer Database"
      UserData:
        Fn::Base64: |
          #!/bin/bash -ex

          # Update system
          sudo yum update -y

          # Install MySQL Server
          sudo wget https://dev.mysql.com/get/mysql80-community-release-el9-1.noarch.rpm
          sudo dnf install mysql80-community-release-el9-1.noarch.rpm -y
          sudo rpm --import https://repo.mysql.com/RPM-GPG-KEY-mysql-2023
          sudo dnf install mysql-community-server -y
          sudo yum install nc -y

          # Start MySQL
          sudo systemctl start mysqld
          sudo systemctl enable mysqld

          # Get the temporary root password
          temp_password=$(sudo grep 'temporary password' /var/log/mysqld.log | awk '{print $NF}')

          # Configure MySQL for remote access
          sudo tee /etc/my.cnf.d/mysql-listen.cnf << EOF
          [mysqld]
          bind-address = 0.0.0.0
          EOF

          # Reset root password and create test user
          mysql --connect-expired-password -u root -p"${temp_password}" << EOF
          ALTER USER 'root'@'localhost' IDENTIFIED BY 'TestPassword@1234';
          CREATE USER 'testuser'@'%' IDENTIFIED BY 'TestPassword@1234';
          GRANT ALL PRIVILEGES ON *.* TO 'testuser'@'%';
          FLUSH PRIVILEGES;
          EOF

          # Restart MySQL to apply changes
          sudo systemctl restart mysqld

          # Set hostname
          sudo hostnamectl set-hostname mysql.internal.com

          # Optional: Install some useful tools
          sudo yum install -y htop jq

          # Configure hostname:
          curl --silent http://169.254.169.254/latest/dynamic/instance-identity/document > /home/ec2-user/iid
          export instance_interface=$(curl --silent http://169.254.169.254/latest/meta-data/network/interfaces/macs/)
          export instance_vpcid=$(curl --silent http://169.254.169.254/latest/meta-data/network/interfaces/macs/$instance_interface/vpc-id)
          export instance_az=$(cat /home/ec2-user/iid |grep 'availability' | awk -F': ' '{print $2}' | awk -F',' '{print $1}')
          export instance_ip=$(cat /home/ec2-user/iid |grep 'privateIp' | awk -F': ' '{print $2}' | awk -F',' '{print $1}' | awk -F'"' '{print$2}')
          export instance_region=$(cat /home/ec2-user/iid |grep 'region' | awk -F': ' '{print $2}' | awk -F',' '{print $1}' | awk -F'"' '{print$2}')

          echo "MySQL installation complete. Root and testuser password is: TestPassword@1234"

          # Create a simple Python socket server that listens on port 1024
          cat << 'EOF' > /usr/local/bin/test-listener.py
          #!/usr/bin/env python3
          import socket
          import sys

          server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
          server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
          server.bind(('0.0.0.0', 1024))
          server.listen(1)

          while True:
              conn, addr = server.accept()
              data = conn.recv(1024)
              conn.close()
          EOF

          chmod +x /usr/local/bin/test-listener.py

          # Create a systemd service for the listener
          cat << 'EOF' > /etc/systemd/system/test-listener.service
          [Unit]
          Description=Test Listener on Port 1024
          After=network.target

          [Service]
          ExecStart=/usr/local/bin/test-listener.py
          Restart=always

          [Install]
          WantedBy=multi-user.target
          EOF

          # Enable and start the service
          systemctl enable test-listener.service
          systemctl start test-listener.service

          dnf install cronie -y
          # Create script to flush MySQL hosts with password
          cat << 'EOF' > /usr/local/bin/flush-mysql-hosts.sh
          #!/bin/bash
          /usr/bin/mysqladmin -u testuser -p'TestPassword@1234' flush-hosts
          EOF

          # Make the script executable
          chmod +x /usr/local/bin/flush-mysql-hosts.sh

          # Secure the script as it contains password
          chmod 700 /usr/local/bin/flush-mysql-hosts.sh

          # Add to crontab (runs every 5 minutes)
          (crontab -l 2>/dev/null; echo "*/5 * * * * /usr/local/bin/flush-mysql-hosts.sh") | crontab -




  # Workoad Instance 2:
  ProdVPC1WorkloadInstance3:
    Type: AWS::EC2::Instance
    Properties:
      PrivateIpAddress: 10.0.2.55
      ImageId: !Ref LatestAmiId
      InstanceType: !Ref InstanceType
      IamInstanceProfile: !Ref SSMInstanceProfile      
      SubnetId: !Ref ProdVPC1WorkloadSubnet2
      SecurityGroupIds:
        - !Ref ProdVPC1WorkloadSecurityGroup
      Tags:
        - Key: Name
          Value: "PROD - PII Sanitized Customer Database"
      UserData:
        Fn::Base64: |
          #!/bin/bash -ex

          # Update system
          sudo yum update -y

          # Install MySQL Server
          sudo wget https://dev.mysql.com/get/mysql80-community-release-el9-1.noarch.rpm
          sudo dnf install mysql80-community-release-el9-1.noarch.rpm -y
          sudo rpm --import https://repo.mysql.com/RPM-GPG-KEY-mysql-2023
          sudo dnf install mysql-community-server -y
          sudo yum install nc -y

          # Start MySQL
          sudo systemctl start mysqld
          sudo systemctl enable mysqld

          # Get the temporary root password
          temp_password=$(sudo grep 'temporary password' /var/log/mysqld.log | awk '{print $NF}')

          # Configure MySQL for remote access
          sudo tee /etc/my.cnf.d/mysql-listen.cnf << EOF
          [mysqld]
          bind-address = 0.0.0.0
          EOF

          # Reset root password and create test user
          mysql --connect-expired-password -u root -p"${temp_password}" << EOF
          ALTER USER 'root'@'localhost' IDENTIFIED BY 'TestPassword@1234';
          CREATE USER 'testuser'@'%' IDENTIFIED BY 'TestPassword@1234';
          GRANT ALL PRIVILEGES ON *.* TO 'testuser'@'%';
          FLUSH PRIVILEGES;
          EOF

          # Restart MySQL to apply changes
          sudo systemctl restart mysqld

          # Set hostname
          sudo hostnamectl set-hostname mysql.internal.com

          # Optional: Install some useful tools
          sudo yum install -y htop jq

          # Configure hostname:
          curl --silent http://169.254.169.254/latest/dynamic/instance-identity/document > /home/ec2-user/iid
          export instance_interface=$(curl --silent http://169.254.169.254/latest/meta-data/network/interfaces/macs/)
          export instance_vpcid=$(curl --silent http://169.254.169.254/latest/meta-data/network/interfaces/macs/$instance_interface/vpc-id)
          export instance_az=$(cat /home/ec2-user/iid |grep 'availability' | awk -F': ' '{print $2}' | awk -F',' '{print $1}')
          export instance_ip=$(cat /home/ec2-user/iid |grep 'privateIp' | awk -F': ' '{print $2}' | awk -F',' '{print $1}' | awk -F'"' '{print$2}')
          export instance_region=$(cat /home/ec2-user/iid |grep 'region' | awk -F': ' '{print $2}' | awk -F',' '{print $1}' | awk -F'"' '{print$2}')
  
  # ---------- End of Prod VPC 1 Resources ----------
  # ---------- Dev VPC 1 Resources ----------
  # ---------- Dev VPC 1 ----------
  DevVPC1:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W60
            reason: "VPC Flow logs not used in workshop"
    Type: AWS::EC2::VPC
    Properties: 
      CidrBlock: 10.32.0.0/16
      Tags: 
        - Key: Name
          Value: "dev-vpc1-us-east-2"
  
  # ---------- Dev VPC 1 IGW and IGW Attachment ----------
  DevVPC1IGW:
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags: 
        - Key: Name
          Value: "dev-vpc1-igw-us-east-2"

  DevVPC1IGWAttachment:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      InternetGatewayId: !Ref DevVPC1IGW
      VpcId: !Ref DevVPC1
  
  # ---------- Dev VPC 1 Subnets ----------
  # CWAN Subnets:
  DevVPC1CWANSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId:
        Ref: DevVPC1
      CidrBlock: 10.32.0.0/28
      AvailabilityZone: !Select
        - 0
        - Fn::GetAZs: !Ref AWS::Region
      MapPublicIpOnLaunch: false
      Tags:
        - Key: Name
          Value: "dev-vpc1-cwan-subnet1-us-east-2"

  DevVPC1CWANSubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref DevVPC1
      CidrBlock: 10.32.0.16/28
      AvailabilityZone: !Select [1, Fn::GetAZs: !Ref AWS::Region]
      MapPublicIpOnLaunch: false
      Tags:
        - Key: Name
          Value: "dev-vpc1-cwan-subnet2-us-east-2"  
  
  # Endpoint Subnets:
  DevVPC1EndpointSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref DevVPC1
      CidrBlock: 10.32.0.32/28
      AvailabilityZone: !Select [0, Fn::GetAZs: !Ref AWS::Region]
      MapPublicIpOnLaunch: false
      Tags:
        - Key: Name
          Value: "dev-vpc1-endpoint-subnet1-us-east-2"

  DevVPC1EndpointSubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref DevVPC1
      CidrBlock: 10.32.0.48/28
      AvailabilityZone: !Select [1, Fn::GetAZs: !Ref AWS::Region]
      MapPublicIpOnLaunch: false
      Tags:
        - Key: Name
          Value: "dev-vpc1-endpoint-subnet2-us-east-2"  

  # Workload Subnets:
  DevVPC1WorkloadSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref DevVPC1
      CidrBlock: 10.32.1.0/24
      AvailabilityZone: !Select [0, Fn::GetAZs: !Ref AWS::Region]
      MapPublicIpOnLaunch: false
      Tags:
        - Key: Name
          Value: "dev-vpc1-workload-subnet1-us-east-2"

  DevVPC1WorkloadSubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref DevVPC1
      CidrBlock: 10.32.2.0/24
      AvailabilityZone: !Select [1, Fn::GetAZs: !Ref AWS::Region]
      MapPublicIpOnLaunch: false
      Tags:
        - Key: Name
          Value: "dev-vpc1-workload-subnet2-us-east-2"
          
  # Public Subnets:
  DevVPC1PublicSubnet1:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W33
            reason: "Public Subnet, public IPs required"
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref DevVPC1
      CidrBlock: 10.32.3.0/24
      AvailabilityZone: !Select [0, Fn::GetAZs: !Ref AWS::Region]
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value: "dev-vpc1-public-subnet1-us-east-2"

  DevVPC1PublicSubnet2:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W33
            reason: "Public Subnet, public IPs required"
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref DevVPC1
      CidrBlock: 10.32.4.0/24
      AvailabilityZone: !Select [1, Fn::GetAZs: !Ref AWS::Region]
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value: "dev-vpc1-public-subnet2-us-east-2"

  # ---------- Dev VPC 1 Route Tables and Subnet Associations ----------
  # CWAN Route Tables:
  DevVPC1CWANRTB1:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref DevVPC1
      Tags:
        - Key: Name
          Value: "dev-vpc1-cwan-rtb1-us-east-2"
  
  DevVPC1CWANRTB2:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref DevVPC1
      Tags:
        - Key: Name
          Value: "dev-vpc1-cwan-rtb2-us-east-2"  

  # CWAN Route Tables Subnet Associations:
  DevVPC1CWANRTB1Association:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref DevVPC1CWANRTB1
      SubnetId: !Ref DevVPC1CWANSubnet1
  
  DevVPC1CWANRTB2Association:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref DevVPC1CWANRTB2
      SubnetId: !Ref DevVPC1CWANSubnet2  

  # Endpoint Route Tables:
  DevVPC1EndpointRTB1:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref DevVPC1
      Tags:
        - Key: Name
          Value: "dev-vpc1-endpoint-rtb1-us-east-2"
  
  DevVPC1EndpointRTB2:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref DevVPC1
      Tags:
        - Key: Name
          Value: "dev-vpc1-endpoint-rtb2-us-east-2"  

  # Endpoint Route Tables Subnet Associations:
  DevVPC1EndpointRTB1Association:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref DevVPC1EndpointRTB1
      SubnetId: !Ref DevVPC1EndpointSubnet1
  
  DevVPC1EndpointRTB2Association:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref DevVPC1EndpointRTB2
      SubnetId: !Ref DevVPC1EndpointSubnet2

  # Workload Route Tables:  
  DevVPC1WorkloadRTB1:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref DevVPC1
      Tags:
        - Key: Name
          Value: "dev-vpc1-workload-rtb1-us-east-2"
  
  DevVPC1WorkloadRTB2:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref DevVPC1
      Tags:
        - Key: Name
          Value: "dev-vpc1-workload-rtb2-us-east-2"
  
  # Workload Route Tables Subnet Associations:
  DevVPC1WorkloadRTB1Association:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref DevVPC1WorkloadRTB1
      SubnetId: !Ref DevVPC1WorkloadSubnet1
  
  DevVPC1WorkloadRTB2Association:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref DevVPC1WorkloadRTB2
      SubnetId: !Ref DevVPC1WorkloadSubnet2
      
  # Public Route Tables:
  DevVPC1PublicRTB1:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref DevVPC1
      Tags:
        - Key: Name
          Value: "dev-vpc1-public-rtb1-us-east-2"

  DevVPC1PublicRTB2:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref DevVPC1
      Tags:
        - Key: Name
          Value: "dev-vpc1-public-rtb2-us-east-2"

  # Public Route Tables Subnet Associations:
  DevVPC1PublicRTB1Association:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref DevVPC1PublicRTB1
      SubnetId: !Ref DevVPC1PublicSubnet1

  DevVPC1PublicRTB2Association:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref DevVPC1PublicRTB2
      SubnetId: !Ref DevVPC1PublicSubnet2

  # ---------- Dev VPC 1 NAT Gateways and EIPs ----------
  # NAT Gateway 1:
  DevVPC1NATGW1EIP:
    Type: AWS::EC2::EIP
    Properties:
      Domain: vpc

  DevVPC1NATGW1:
    Type: AWS::EC2::NatGateway
    Properties:
      AllocationId: !GetAtt DevVPC1NATGW1EIP.AllocationId
      SubnetId: !Ref DevVPC1PublicSubnet1
      Tags:
        - Key: Name
          Value: "dev-vpc1-natgw1-us-east-2"

  # ---------- AWS Cloud WAN attachment and routes ----------
  # Create Dev VPC 1 Cloud WAN Attachment:
  DevVPC1CWANAttachment:
    Type: AWS::NetworkManager::VpcAttachment
    Properties:
      CoreNetworkId: !GetAtt RetrieveCoreNetworkIdAndArn.CoreNetworkId
      VpcArn: !Sub "arn:aws:ec2:${AWS::Region}:${AWS::AccountId}:vpc/${DevVPC1}"
      SubnetArns:
        - !Sub "arn:aws:ec2:${AWS::Region}:${AWS::AccountId}:subnet/${DevVPC1CWANSubnet1}"
        - !Sub "arn:aws:ec2:${AWS::Region}:${AWS::AccountId}:subnet/${DevVPC1CWANSubnet2}"
      Tags:
        - Key: Name
          Value: "dev-vpc1-attachment-us-east-2"
        - Key: domain
          Value: Development

  # Create route tables with updated routing
  
  # Default route to NAT Gateway for internet access
  DevVPC1WorkloadRTB1DefaultRoute:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref DevVPC1WorkloadRTB1
      DestinationCidrBlock: 0.0.0.0/0
      NatGatewayId: !Ref DevVPC1NATGW1

  # DevVPC1WorkloadRTB2DefaultRoute:
  #   Type: AWS::EC2::Route
  #   Properties:
  #     RouteTableId: !Ref DevVPC1WorkloadRTB2
  #     DestinationCidrBlock: 0.0.0.0/0
  #     NatGatewayId: !Ref DevVPC1NATGW2
  
  DevVPC1WorkloadRTB2DefaultRoute:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref DevVPC1WorkloadRTB2
      DestinationCidrBlock: 0.0.0.0/0
      NatGatewayId: !Ref DevVPC1NATGW1

  # Routes for 10.0.0.0/8 via Cloud WAN
  DevVPC1WorkloadRTB1CloudWANRoute:
    DependsOn: DevVPC1CWANAttachment
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref DevVPC1WorkloadRTB1
      DestinationCidrBlock: 10.0.0.0/8
      CoreNetworkArn: !GetAtt RetrieveCoreNetworkIdAndArn.CoreNetworkArn

  DevVPC1WorkloadRTB2CloudWANRoute:
    DependsOn: DevVPC1CWANAttachment
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref DevVPC1WorkloadRTB2
      DestinationCidrBlock: 10.0.0.0/8
      CoreNetworkArn: !GetAtt RetrieveCoreNetworkIdAndArn.CoreNetworkArn
  
  # Route for 172.20.0.0/16 via Cloud WAN in Dev VPC1 Workload RTB1
  DevVPC1WorkloadRTB1AdditionalRoute:
    DependsOn: DevVPC1CWANAttachment
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref DevVPC1WorkloadRTB1
      DestinationCidrBlock: 172.20.0.0/16
      CoreNetworkArn: !GetAtt RetrieveCoreNetworkIdAndArn.CoreNetworkArn

  # Route for 172.20.0.0/16 via Cloud WAN in Dev VPC1 Workload RTB2
  DevVPC1WorkloadRTB2AdditionalRoute:
    DependsOn: DevVPC1CWANAttachment
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref DevVPC1WorkloadRTB2
      DestinationCidrBlock: 172.20.0.0/16
      CoreNetworkArn: !GetAtt RetrieveCoreNetworkIdAndArn.CoreNetworkArn

  # Default routes to IGW in public subnets
  DevVPC1PublicRTB1DefaultRoute:
    DependsOn: DevVPC1IGWAttachment
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref DevVPC1PublicRTB1
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref DevVPC1IGW

  DevVPC1PublicRTB2DefaultRoute:
    DependsOn: DevVPC1IGWAttachment
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref DevVPC1PublicRTB2
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref DevVPC1IGW

  # ---------- Create Security Groups ----------
  # Create Workload SG:
  DevVPC1WorkloadSecurityGroup:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W40
            reason: "Security Groups egress with an IpProtocol of -1 is required"
          - id: W5
            reason: "Security Groups found with cidr open to world on egress is required"
          - id: W42
            reason: "Security Groups ingress with an ipProtocol of -1 is required"
          - id: W9
            reason: "Security Groups found with ingress cidr that is not /32 is required"
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Dev VPC 1 Workload EC2 Instance Security Group
      VpcId: !Ref DevVPC1
      SecurityGroupIngress:
        - CidrIp: 10.0.0.0/8
          Description: Allowing inbound connection from 10.0.0.0/8 CIDR.
          IpProtocol: "-1"
          FromPort: -1
          ToPort: -1          
        - CidrIp: 172.20.0.0/16
          Description: Allowing inbound connection from 172.20.0.0/16 CIDR.
          IpProtocol: "-1"
          FromPort: -1
          ToPort: -1   
      SecurityGroupEgress:
        - CidrIp: 0.0.0.0/0
          Description: Allowing outbound connection to 0.0.0.0/0 CIDR.
          IpProtocol: "-1"
          FromPort: -1
          ToPort: -1
      Tags:
        - Key: Name
          Value: "dev-vpc1-workload-sg-us-east-2"

  # Create EC2 instance connect endpoint SG:
  DevVPC1EndpointSecurityGroup:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W40
            reason: "Security Groups egress with an IpProtocol of -1 is required"
          - id: W5
            reason: "Security Groups found with cidr open to world on egress is required"
          - id: W42
            reason: "Security Groups ingress with an ipProtocol of -1 is required"
          - id: W9
            reason: "Security Groups found with ingress cidr that is not /32 is required"
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Dev VPC 1 Endpoint Security Group
      VpcId: !Ref DevVPC1
      Tags:
        - Key: Name
          Value: "dev-vpc-endpoint-sg-us-east-2"

  DevVPC1WorkloadSecurityGroupIngressEIC:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref DevVPC1WorkloadSecurityGroup
      Description: Allowing inbound connenciton from EC2 Instance Connect (EIC).
      IpProtocol: tcp
      FromPort: 22
      ToPort: 22
      SourceSecurityGroupId: !Ref DevVPC1EndpointSecurityGroup
  
  DevVPC1EndpointSecurityGroupEgressEIC:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      GroupId: !Ref DevVPC1EndpointSecurityGroup
      Description: Allowing outbound connection to EC2 Instance Connect (EIC).
      IpProtocol: tcp
      FromPort: 22
      ToPort: 22
      DestinationSecurityGroupId: !Ref DevVPC1WorkloadSecurityGroup

  # ---------- EC2 Instance Connect Endpoint ----------
  DevVPC1EICEndpoint:
    Type: AWS::EC2::InstanceConnectEndpoint
    Properties:
      PreserveClientIp: false
      SecurityGroupIds: 
        - !Ref DevVPC1EndpointSecurityGroup
      SubnetId: !Ref DevVPC1EndpointSubnet1
      Tags: 
        - Key: Name
          Value: !Sub "dev-vpc1-eic-us-east-2"

  # ---------- Create Workload EC2 Instances ----------
  # Workload Instance 1:
  DevVPC1WorkloadInstance1:
    Type: AWS::EC2::Instance
    Properties:
      ImageId: !Ref LatestAmiId
      InstanceType: !Ref InstanceType
      IamInstanceProfile: !Ref SSMInstanceProfile      
      SubnetId: !Ref DevVPC1WorkloadSubnet1
      SecurityGroupIds:
        - !Ref DevVPC1WorkloadSecurityGroup
      Tags:
        - Key: Name
          Value: "DEV - Test Instance"
      UserData:
        Fn::Base64: |
          #!/bin/bash -ex

          # Update system
          sudo yum update -y

          # Install MySQL Client
          sudo wget https://dev.mysql.com/get/mysql80-community-release-el9-1.noarch.rpm
          sudo dnf install mysql80-community-release-el9-1.noarch.rpm -y
          sudo rpm --import https://repo.mysql.com/RPM-GPG-KEY-mysql-2023
          sudo dnf install mysql-community-client -y
          sudo yum install -y nc

          # Install cronie
          sudo dnf install cronie -y

          # Start and enable crond service
          sudo systemctl start crond
          sudo systemctl enable crond

          # Create a script for DNS cache flush
          cat << 'EOF' | sudo tee /usr/local/bin/flush-dns-cache.sh
          #!/bin/bash
          systemctl restart systemd-resolved
          EOF

          # Make the script executable
          sudo chmod +x /usr/local/bin/flush-dns-cache.sh

          # Add cron job to run every minute
          echo "* * * * * root /usr/local/bin/flush-dns-cache.sh" | sudo tee /etc/cron.d/flush-dns-cache

          # Set proper permissions for the cron job file
          sudo chmod 644 /etc/cron.d/flush-dns-cache
  
  # ---------- End of Dev VPC 1 Resources ----------

# ---------- Inspection VPC 1 Resources ----------
  # ---------- Inspection VPC 1 ----------
  InspectionVPC1:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W60
            reason: "VPC Flow logs not used in workshop"
    Type: AWS::EC2::VPC
    Properties: 
      CidrBlock: 100.64.1.0/24
      Tags: 
        - Key: Name
          Value: "inspection-vpc1-us-east-2"

  # ---------- Inspection VPC 1 IGW and IGW Attachment----------
  InspectionVPC1IGW:
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags: 
        - Key: Name
          Value: "inspection-vpc1-igw-us-east-2"
  
  InspectionVPC1IGWAttachment:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      InternetGatewayId: !Ref InspectionVPC1IGW
      VpcId: !Ref InspectionVPC1
  
  # ---------- Inspection VPC 1 Subnets ----------
  # CWAN Subnets:
  InspectionVPC1CWANSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref InspectionVPC1
      CidrBlock: 100.64.1.0/28
      AvailabilityZone: !Select
        - 0
        - Fn::GetAZs: !Ref AWS::Region
      MapPublicIpOnLaunch: false
      Tags:
        - Key: Name
          Value: "inspection-vpc1-cwan-subnet1-us-east-2"

  InspectionVPC1CWANSubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref InspectionVPC1
      CidrBlock: 100.64.1.16/28
      AvailabilityZone: !Select [1, Fn::GetAZs: !Ref AWS::Region]
      MapPublicIpOnLaunch: false
      Tags:
        - Key: Name
          Value: "inspection-vpc1-cwan-subnet2-us-east-2"  
  
  # Firewall Endpoint Subnets:
  InspectionVPC1FirewallSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref InspectionVPC1
      CidrBlock: 100.64.1.32/28
      AvailabilityZone: !Select [0, Fn::GetAZs: !Ref AWS::Region]
      MapPublicIpOnLaunch: false
      Tags:
        - Key: Name
          Value: "inspection-vpc1-fwe-subnet1-us-east-2"

  InspectionVPC1FirewallSubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref InspectionVPC1
      CidrBlock: 100.64.1.48/28
      AvailabilityZone: !Select [1, Fn::GetAZs: !Ref AWS::Region]
      MapPublicIpOnLaunch: false
      Tags:
        - Key: Name
          Value: "inspection-vpc1-fwe-subnet2-us-east-2"  

  # Public Subnets:
  InspectionVPC1PublicSubnet1:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W33
            reason: "Public Subnet, public IPs required"
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref InspectionVPC1
      CidrBlock: 100.64.1.64/28
      AvailabilityZone: !Select [0, Fn::GetAZs: !Ref AWS::Region]
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value: "inspection-vpc1-public-subnet1-us-east-2"

  InspectionVPC1PublicSubnet2:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W33
            reason: "Public Subnet, public IPs required"
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref InspectionVPC1
      CidrBlock: 100.64.1.80/28
      AvailabilityZone: !Select [1, Fn::GetAZs: !Ref AWS::Region]
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value: "inspection-vpc1-public-subnet2-us-east-2"

  # ---------- Inspection VPC 1 Route Tables and Subnet Associations ----------
  # CWAN Route Tables:
  InspectionVPC1CWANRTB1:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref InspectionVPC1
      Tags:
        - Key: Name
          Value: "inspection-vpc1-cwan-rtb1-us-east-2"
  
  InspectionVPC1CWANRTB2:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref InspectionVPC1
      Tags:
        - Key: Name
          Value: "inspection-vpc1-cwan-rtb2-us-east-2"  

  # CWAN Route Tables Subnet Associations:
  InspectionVPC1CWANRTB1Association:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref InspectionVPC1CWANRTB1
      SubnetId: !Ref InspectionVPC1CWANSubnet1
  
  InspectionVPC1CWANRTB2Association:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref InspectionVPC1CWANRTB2
      SubnetId: !Ref InspectionVPC1CWANSubnet2  

  # Firewall Endpoint Route Tables:
  InspectionVPC1FirewallRTB1:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref InspectionVPC1
      Tags:
        - Key: Name
          Value: "inspection-vpc1-fwe-rtb1-us-east-2"
  
  InspectionVPC1FirewallRTB2:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref InspectionVPC1
      Tags:
        - Key: Name
          Value: "inspection-vpc1-fwe-rtb2-us-east-2"  

  # Firewall Endpoint Route Tables Subnet Associations:
  InspectionVPC1FirewallRTB1Association:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref InspectionVPC1FirewallRTB1
      SubnetId: !Ref InspectionVPC1FirewallSubnet1
  
  InspectionVPC1FirewallRTB2Association:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref InspectionVPC1FirewallRTB2
      SubnetId: !Ref InspectionVPC1FirewallSubnet2

  # Public Route Tables:  
  InspectionVPC1PublicRTB1:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref InspectionVPC1
      Tags:
        - Key: Name
          Value: "inspection-vpc1-public-rtb1-us-east-2"
  
  InspectionVPC1PublicRTB2:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref InspectionVPC1
      Tags:
        - Key: Name
          Value: "inspection-vpc1-public-rtb2-us-east-2"
  
  # Public Route Tables Subnet Associations:
  InspectionVPC1PublicRTB1Association:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref InspectionVPC1PublicRTB1
      SubnetId: !Ref InspectionVPC1PublicSubnet1
  
  InspectionVPC1PublicRTB2Association:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref InspectionVPC1PublicRTB2
      SubnetId: !Ref InspectionVPC1PublicSubnet2

  # ---------- Inspection VPC 1 NAT Gateways and EIPs ----------
  # NAT Gateway 1:
  InspectionVPC1NATGW1EIP1:
    Type: AWS::EC2::EIP
    Properties:
      Domain: vpc

  InspectionVPC1NATGW1:
    Type: AWS::EC2::NatGateway
    Properties:
      AllocationId: !GetAtt InspectionVPC1NATGW1EIP1.AllocationId
      SubnetId: !Ref InspectionVPC1PublicSubnet1
      Tags:
        - Key: Name
          Value: "inspection-vpc1-natgw1-us-east-2"

  # NAT Gateway 2:
  InspectionVPC1NATGW1EIP2:
    Type: AWS::EC2::EIP
    Properties:
      Domain: vpc

  InspectionVPC1NATGW2:
    Type: AWS::EC2::NatGateway
    Properties:
      AllocationId: !GetAtt InspectionVPC1NATGW1EIP2.AllocationId
      SubnetId: !Ref InspectionVPC1PublicSubnet2
      Tags:
        - Key: Name
          Value: "inspection-vpc1-natgw2-us-east-2"

  # ---------- AWS Network Firewall (ANFW) and related resources ----------

  # Network Firewall resource
  InspectionVPC1Anfw1:
    DependsOn: [InspectionVPC1Anfw1RulesPolicy1]
    Type: AWS::NetworkFirewall::Firewall
    Properties:
      FirewallName: Network-Firewall-us-east-2
      FirewallPolicyArn: !GetAtt InspectionVPC1Anfw1RulesPolicy1.FirewallPolicyArn
      EnabledAnalysisTypes: 
        - TLS_SNI
        - HTTP_HOST
      VpcId: !Ref InspectionVPC1
      SubnetMappings:
        - SubnetId: !Ref InspectionVPC1FirewallSubnet1
        - SubnetId: !Ref InspectionVPC1FirewallSubnet2
  
  # Firewall Policy
  InspectionVPC1Anfw1RulesPolicy1:
    Type: AWS::NetworkFirewall::FirewallPolicy
    Properties:
      FirewallPolicy:
        StatelessDefaultActions:
          - aws:forward_to_sfe
        StatelessFragmentDefaultActions:
          - aws:forward_to_sfe
        StatefulEngineOptions:
          RuleOrder: STRICT_ORDER
        StatefulDefaultActions:
          - aws:alert_established
        StatefulRuleGroupReferences:
          # Custom Suricata Rule Group
          - ResourceArn: !Ref StatefulRuleGroup
            Priority: 1      
      FirewallPolicyName: "Network-Firewall-Policy-us-east-2"
      Tags:
        - Key: Name
          Value: "Network-Firewall-Policy-us-east-2"  

  StatefulRuleGroup:
    Type: 'AWS::NetworkFirewall::RuleGroup'
    Properties:
      RuleGroupName: StatefulRuleGroup
      Type: STATEFUL
      Capacity: 100
      RuleGroup:
        RuleVariables: 
          IPSets: 
            DEV_CIDR: 
              Definition: 
                - "10.32.0.0/16"
                - "10.160.0.0/16"
            INSPECTION_VPC: 
              Definition: 
                - "100.64.1.0/24"
                - "100.64.2.0/24"
            ON_PREM_CIDR: 
              Definition: 
                - "172.20.0.0/16"
            PROD_CIDR: 
              Definition: 
                - "10.0.0.0/16"
                - "10.128.0.0/16"
            PROD_DB: 
              Definition: 
                - "10.0.2.50"
            SANITIZED_PROD_DB: 
              Definition: 
                - "10.0.2.55"
            PROD_INTERNAL_API: 
              Definition: 
                - "10.0.1.100"
        RulesSource:
          RulesString: >-
            # Insert firewall rules 

        StatefulRuleOptions:
          RuleOrder: STRICT_ORDER

  # Firewall Logs - Flow
  InspectionVPC1Anfw1LogFlowGroup:
    Metadata:
      checkov:
        skip:
          - id: "CKV_AWS_158"
            comment: "Ensure that CloudWatch Log Group is encrypted by KMS"
      cfn_nag:
        rules_to_suppress:
          - id: W84
            reason: "CloudWatch Log Group does not require KMS encryption"
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: "/network-firewall/flow-logs/us-east-2/"
      RetentionInDays: 7

  # Firewall Logs - Aler
  InspectionVPC1Anfw1LogAlertGroup:
    Metadata:
      checkov:
        skip:
          - id: "CKV_AWS_158"
            comment: "Ensure that CloudWatch Log Group is encrypted by KMS"
      cfn_nag:
        rules_to_suppress:
          - id: W84
            reason: "CloudWatch Log Group does not require KMS encryption"
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: "/network-firewall/alert-logs/us-east-2/"
      RetentionInDays: 7

  # Firewall Log - Policy reference
  InspectionVPC1Anfw1Log:
    Type: AWS::NetworkFirewall::LoggingConfiguration
    Properties:
      FirewallArn: !Ref InspectionVPC1Anfw1
      LoggingConfiguration:
        LogDestinationConfigs:
          - LogType: FLOW
            LogDestinationType: CloudWatchLogs
            LogDestination:
              logGroup: !Ref InspectionVPC1Anfw1LogFlowGroup
          - LogType: ALERT
            LogDestinationType: CloudWatchLogs
            LogDestination:
              logGroup: !Ref InspectionVPC1Anfw1LogAlertGroup

  # ---------- Lambda and Custom Resource to retrieve ANFW Endpoint IDs ----------
  # CloudWatch Log Group for DescribeVpceIdLambda Function:
  DescribeVpceIdLambdaLogGroup:
    Metadata:
      checkov:
        skip:
          - id: "CKV_AWS_158"
            comment: "Ensure that CloudWatch Log Group is encrypted by KMS"
      cfn_nag:
        rules_to_suppress:
          - id: W84
            reason: "CloudWatch Log Group does not require KMS encryption"
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: "/aws/lambda/us-east-2-DescribeVpceId"
      RetentionInDays: 1
  
  # Lambda Function to retrieve ANFW Endpoint IDs:
  DescribeVpceIdLambda:
    Metadata:
      checkov:
        skip:
          - id: "CKV_AWS_117"
            comment: "Ensure that AWS Lambda function is configured inside a VPC"
          - id: "CKV_AWS_116"
            comment: "Ensure that AWS Lambda function is configured for a Dead Letter Queue(DLQ)"
          - id: "CKV_AWS_115"
            comment: "Ensure that AWS Lambda function is configured for function-level concurrent execution limit"
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: "Lambda function does not need to be deployed in a VPC"
          - id: W92
            reason: "Lambda function does not need ReservedConcurrentExecutions"
    Type: AWS::Lambda::Function
    DependsOn: DescribeVpceIdLambdaLogGroup
    Properties:
      FunctionName: DescribeVpceId-us-east-2
      Handler: "index.handler"
      Role: !GetAtt IamRoleLambdaCFn.Arn
      LoggingConfig:
        LogGroup: !Ref DescribeVpceIdLambdaLogGroup 
      Code:
        ZipFile: |
          import boto3
          import cfnresponse
          import json
          import logging

          def handler(event, context):
              logger = logging.getLogger()
              logger.setLevel(logging.INFO)

              responseData = {}
              responseStatus = cfnresponse.FAILED

              eventinfo = json.dumps(event)
              logger.info(f"Received event: {eventinfo}")

              if event["RequestType"] == "Delete":
                  responseStatus = cfnresponse.SUCCESS
                  cfnresponse.send(event, context, responseStatus, responseData, "CustomResourcePhysicalID")
              if event["RequestType"] == "Create":
                  try:
                      Az1 = event["ResourceProperties"]["Az1"]
                      Az2 = event["ResourceProperties"]["Az2"]
                      FwArn = event["ResourceProperties"]["FwArn"]
                  except Exception as e:
                      logger.info(f"AZ retrieval failure: {e}")

                  try:
                      nfw = boto3.client('network-firewall')
                  except Exception as e:
                      logger.info(f"boto3.client failure: {e}")

                  try:
                      NfwResponse=nfw.describe_firewall(FirewallArn=FwArn)
                      VpceId1 = NfwResponse['FirewallStatus']['SyncStates'][Az1]['Attachment']['EndpointId']
                      VpceId2 = NfwResponse['FirewallStatus']['SyncStates'][Az2]['Attachment']['EndpointId']
                  except Exception as e:
                      logger.info(f"ec2.describe_firewall failure: {e}")

                  responseData['FwVpceId1'] = VpceId1
                  responseData['FwVpceId2'] = VpceId2
                  responseStatus = cfnresponse.SUCCESS
                  print(f"VPCE ID1: {VpceId1}")
                  print(f"VPCE ID2: {VpceId2}")
                  print(f"response data: {responseData}")
                  cfnresponse.send(event, context, responseStatus, responseData)
      Runtime: python3.12
      Timeout: 900

  # Custom resource to retrieve ANFW Endpoint IDs using Lambda function created above:
  RetrieveInspectionVPC1AnfwVpceIds:
    Type: Custom::DescribeVpcEndpoints
    Properties:
      ServiceToken: !GetAtt DescribeVpceIdLambda.Arn
      Az1: !Select [0, Fn::GetAZs: !Ref AWS::Region]
      Az2: !Select [1, Fn::GetAZs: !Ref AWS::Region]
      FwArn: !Ref InspectionVPC1Anfw1

  # ---------- AWS Cloud WAN attachment ----------
  # Create Inspection VPC 1 Cloud WAN Attachment:
  InspectionVPC1CWANAttachment:
    Type: AWS::NetworkManager::VpcAttachment
    Properties:
      CoreNetworkId: !GetAtt RetrieveCoreNetworkIdAndArn.CoreNetworkId
      VpcArn: !Sub "arn:aws:ec2:${AWS::Region}:${AWS::AccountId}:vpc/${InspectionVPC1}"
      SubnetArns:
        - !Sub "arn:aws:ec2:${AWS::Region}:${AWS::AccountId}:subnet/${InspectionVPC1CWANSubnet1}"
        - !Sub "arn:aws:ec2:${AWS::Region}:${AWS::AccountId}:subnet/${InspectionVPC1CWANSubnet2}"
      Options:
        ApplianceModeSupport: true
      Tags:
        - Key: Name
          Value: "inspection-vpc1-attachment-us-east-2"
        - Key: domain
          Value: InspectionNFG

  # ---------- Add Routes ----------
  # Create default route in CWAN route tables with ANFW endpoints as the next hop:
  InspectionVPC1CWANRTB1DefaultRoute:
    DependsOn: [InspectionVPC1Anfw1]
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref InspectionVPC1CWANRTB1
      DestinationCidrBlock: 0.0.0.0/0
      VpcEndpointId: !GetAtt RetrieveInspectionVPC1AnfwVpceIds.FwVpceId1

  InspectionVPC1CWANRTB2DefaultRoute:
    DependsOn: [InspectionVPC1Anfw1]
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref InspectionVPC1CWANRTB2
      DestinationCidrBlock: 0.0.0.0/0
      VpcEndpointId: !GetAtt RetrieveInspectionVPC1AnfwVpceIds.FwVpceId2

  # Create default route in ANFW route tables with NAT Gateway as the next hop:
  InspectionVPC1FirewallRTB1DefaultRoute:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref InspectionVPC1FirewallRTB1
      DestinationCidrBlock: 0.0.0.0/0
      NatGatewayId: !Ref InspectionVPC1NATGW1

  InspectionVPC1FirewallRTB2DefaultRoute:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref InspectionVPC1FirewallRTB2
      DestinationCidrBlock: 0.0.0.0/0
      NatGatewayId: !Ref InspectionVPC1NATGW2

  # Create summary route in ANFW route tables with Core Network ARN as the next hop:
  InspectionVPC1FirewallRTB1SummaryRoute:
    DependsOn: [InspectionVPC1CWANAttachment]
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref InspectionVPC1FirewallRTB1
      DestinationCidrBlock: 10.0.0.0/8
      CoreNetworkArn: !GetAtt RetrieveCoreNetworkIdAndArn.CoreNetworkArn

  InspectionVPC1FirewallRTB2SummaryRoute:
    DependsOn: [InspectionVPC1CWANAttachment]
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref InspectionVPC1FirewallRTB2
      DestinationCidrBlock: 10.0.0.0/8
      CoreNetworkArn: !GetAtt RetrieveCoreNetworkIdAndArn.CoreNetworkArn
  
  # Create route for 172.20.0.0/16 in ANFW route table 1
  InspectionVPC1FirewallRTB1AdditionalRoute:
    DependsOn: [InspectionVPC1CWANAttachment]
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref InspectionVPC1FirewallRTB1
      DestinationCidrBlock: 172.20.0.0/16
      CoreNetworkArn: !GetAtt RetrieveCoreNetworkIdAndArn.CoreNetworkArn

  # Create route for 172.20.0.0/16 in ANFW route table 2
  InspectionVPC1FirewallRTB2AdditionalRoute:
    DependsOn: [InspectionVPC1CWANAttachment]
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref InspectionVPC1FirewallRTB2
      DestinationCidrBlock: 172.20.0.0/16
      CoreNetworkArn: !GetAtt RetrieveCoreNetworkIdAndArn.CoreNetworkArn

  # Create default route in Public route tables with Internet Gateway as the next hop:
  InspectionVPC1PublicRTB1DefaultRoute:
    DependsOn: [InspectionVPC1IGWAttachment]
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref InspectionVPC1PublicRTB1
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref InspectionVPC1IGW

  InspectionVPC1PublicRTB2DefaultRoute:
    DependsOn: [InspectionVPC1IGWAttachment]
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref InspectionVPC1PublicRTB2
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref InspectionVPC1IGW

  # Create summary route in Public route tables with firewall endpoint as the next hop:
  InspectionVPC1PublicRTB1SummaryRoute:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref InspectionVPC1PublicRTB1
      DestinationCidrBlock: 10.0.0.0/8
      VpcEndpointId: !GetAtt RetrieveInspectionVPC1AnfwVpceIds.FwVpceId1

  InspectionVPC1PublicRTB2SummaryRoute:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref InspectionVPC1PublicRTB2
      DestinationCidrBlock: 10.0.0.0/8
      VpcEndpointId: !GetAtt RetrieveInspectionVPC1AnfwVpceIds.FwVpceId2
  
  # Create route for 172.20.0.0/16 in public route table 1
  InspectionVPC1PublicRTB1AdditionalRoute:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref InspectionVPC1PublicRTB1
      DestinationCidrBlock: 172.20.0.0/16
      VpcEndpointId: !GetAtt RetrieveInspectionVPC1AnfwVpceIds.FwVpceId1

  # Create route for 172.20.0.0/16 in public route table 2
  InspectionVPC1PublicRTB2AdditionalRoute:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref InspectionVPC1PublicRTB2
      DestinationCidrBlock: 172.20.0.0/16
      VpcEndpointId: !GetAtt RetrieveInspectionVPC1AnfwVpceIds.FwVpceId2
  
  # ---------- End of Inspection VPC 1 Resources ----------


  # SSM Instance Role to allow SSM access
  SSMInstanceRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/AmazonSSMFullAccess'

  # SSM Instance Profile to allow SSM access
  SSMInstanceProfile:
    Type: 'AWS::IAM::InstanceProfile'
    Properties:
      Roles:
        - !Ref SSMInstanceRole

# Public Internet VPC for Egress Tests

  PublicInternetVPC:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W60
            reason: "VPC Flow logs not used in workshop"
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: "10.200.0.0/16"
      EnableDnsHostnames: true
      EnableDnsSupport: true
      Tags:
        - Key: Name
          Value: PublicInternetVPC

  PublicInternetSubnet:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W33
            reason: "Public Subnet, public IPs required"
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref PublicInternetVPC
      CidrBlock: "10.200.1.0/24"
      AvailabilityZone: !Select [0, !GetAZs ""]
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value: PublicInternet-Public-Subnet

  PublicInternetIGW:
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags:
      - Key: Name
        Value: PublicInternet-IGW

  PublicInternetGWAttachment:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      InternetGatewayId: !Ref PublicInternetIGW
      VpcId: !Ref PublicInternetVPC

  PublicInternetSG:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W40
            reason: "Security Groups egress with an IpProtocol of -1 is required"
          - id: W5
            reason: "Security Groups found with cidr open to world on egress is required"
          - id: W42
            reason: "Security Groups ingress with an ipProtocol of -1 is required"
          - id: W9
            reason: "Security Groups found with ingress cidr that is not /32 is required"
          - id: W36
            reason: "Description is applied"
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: 'Public Internet Host Security Group'
      VpcId: !Ref PublicInternetVPC
      SecurityGroupIngress:
        - IpProtocol: '-1'
          Description: Allowing inbound connection from 10.0.0.0/8 CIDR.
          FromPort: -1
          ToPort: -1
          CidrIp: 10.0.0.0/8
        - IpProtocol: '-1'
          CidrIp: !Sub "${DevVPC1NATGW1EIP.PublicIp}/32"
        - IpProtocol: '-1'
          CidrIp: !Sub "${InspectionVPC1NATGW1EIP1.PublicIp}/32"
        - IpProtocol: '-1'
          CidrIp: !Sub "${InspectionVPC1NATGW1EIP2.PublicIp}/32"
      SecurityGroupEgress:
        - CidrIp: 0.0.0.0/0
          Description: Allowing outbound connection to 0.0.0.0/0 CIDR.
          IpProtocol: "-1"
          FromPort: -1
          ToPort: -1

  PublicInternetHostRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonSSMFullAccess

  PublicInternetHostProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Path: "/"
      Roles:
        - !Ref PublicInternetHostRole

  PublicInternetHost:
    Type: AWS::EC2::Instance
    Properties:
      ImageId: !Ref LatestAmiId
      InstanceType: t3.small
      IamInstanceProfile: !Ref PublicInternetHostProfile
      SubnetId: !Ref PublicInternetSubnet
      SecurityGroupIds:
        - !Ref PublicInternetSG
      Tags:
        - Key: Name
          Value: Public-Internet-Host
      Tags:
        - Key: Name
          Value: "INTERNET - Public Host on Internet"
      UserData:
        Fn::Base64: |
          #!/bin/bash -ex

          # Update system
          yum update -y

          # Install required services and dependencies
          yum install -y httpd vsftpd nc php php-common php-fpm

          # Disable SELinux
          setenforce 0

          # Disable SELinux permanently
          sed -i 's/SELINUX=enforcing/SELINUX=disabled/' /etc/selinux/config

          # Enable and start services
          systemctl enable httpd
          systemctl start httpd

          # Configure Apache for various ports
          sed -i '/Listen 80/a Listen 8080' /etc/httpd/conf/httpd.conf
          sed -i '/Listen 8080/a Listen 1389' /etc/httpd/conf/httpd.conf
          sed -i '/Listen 1389/a Listen 4444' /etc/httpd/conf/httpd.conf

          # Create main PHP-FPM configuration
          cat << 'EOF' > /etc/php-fpm.conf
          [global]
          pid = /run/php-fpm/php-fpm.pid
          error_log = /var/log/php-fpm/error.log
          daemonize = yes

          include=/etc/php-fpm.d/*.conf
          EOF

          # Configure PHP-FPM
          cat << 'EOF' > /etc/php-fpm.d/www.conf
          [www]
          user = apache
          group = apache
          listen = /run/php-fpm/www.sock
          listen.owner = apache
          listen.group = apache
          listen.mode = 0660

          pm = dynamic
          pm.max_children = 50
          pm.start_servers = 5
          pm.min_spare_servers = 5
          pm.max_spare_servers = 35
          EOF

          # Create required directories
          mkdir -p /run/php-fpm /var/log/php-fpm
          chown apache:apache /run/php-fpm /var/log/php-fpm
          chmod 755 /run/php-fpm /var/log/php-fpm

          # Configure PHP handler
          cat << 'EOF' > /etc/httpd/conf.d/php.conf
          <FilesMatch \.php$>
              SetHandler "proxy:unix:/run/php-fpm/www.sock|fcgi://localhost"
          </FilesMatch>
          AddType application/x-httpd-php .php
          EOF

          # Configure Apache handlers
          cat << 'EOF' > /etc/httpd/conf.d/handlers.conf
          <Directory "/var/www/html">
              Options +ExecCGI
              AddHandler application/x-httpd-php .php
              <FilesMatch "\.php$">
                  SetHandler "proxy:unix:/run/php-fpm/www.sock|fcgi://localhost"
              </FilesMatch>
          </Directory>
          LoadModule proxy_module modules/mod_proxy.so
          LoadModule proxy_fcgi_module modules/mod_proxy_fcgi.so
          EOF

          # Configure SSH for alternate port
          sed -i 's/#Port 22/Port 22\nPort 443/' /etc/ssh/sshd_config

          systemctl restart sshd

          # Create directories and files for cryptomining tests
          mkdir -p /var/www/html/pool

          # Create a dummy executable file
          dd if=/dev/zero of=/var/www/html/cpu64.exe bs=1M count=1

          # Create mining pool configuration file
          cat << 'EOF' > /var/www/html/pool.config
          pool.monero.hashvault.pro:5555;x;x;
          cpubase_usage = IDLE power
          pool = pool.monero.hashvault.pro:5555
          wallet = 4279hWaT5J7ioCsVPXZahGHfxhqJ3Y3gzT1uxxG8aEVGWBYkbnVB61Vfx9weGy79R8YAQE1ouKAan56hRkfTQdp76DKpvi6
          EOF

          # Create mining pool endpoint with improved PHP
          cat << 'EOF' > /var/www/html/pool/index.php
          <?php
          header('Content-Type: application/json');
          header('X-Content-Type-Options: nosniff');
          header('X-Frame-Options: DENY');
          header('X-XSS-Protection: 1; mode=block');

          if ($_SERVER['REQUEST_METHOD'] === 'POST') {
              $input = file_get_contents('php://input');
              if (strpos($input, '"method":"mining.authorize"') !== false && 
                  strpos($input, '"params":["pioner.1","12345"]') !== false) {
                  echo json_encode([
                      'id' => 1,
                      'result' => true,
                      'error' => null,
                      'worker_name' => 'pioner.1'
                  ]);
                  exit;
              }
          }
          http_response_code(403);
          echo json_encode(['error' => 'Unauthorized']);
          ?>
          EOF

          # Set proper permissions
          find /var/www/html -type f -exec chmod 644 {} \;
          chown -R apache:apache /var/www/html/

          # Create .htaccess with security headers
          cat << 'EOF' > /var/www/html/.htaccess
          Header always set X-Content-Type-Options "nosniff"
          Header always set X-Frame-Options "DENY"
          Header always set X-XSS-Protection "1; mode=block"
          Header always set Content-Security-Policy "default-src 'self'"

          <Files "pool.config">
              Header set Content-Type "text/plain"
          </Files>
          <Files "cpu64.exe">
              Header set Content-Type "application/octet-stream"
          </Files>
          EOF

          chmod 644 /var/www/html/.htaccess
          chown apache:apache /var/www/html/.htaccess

          # Enable required Apache modules
          cat << 'EOF' > /etc/httpd/conf.d/security.conf
          LoadModule headers_module modules/mod_headers.so
          LoadModule rewrite_module modules/mod_rewrite.so
          EOF

          # Configure main Apache security settings
          cat << 'EOF' >> /etc/httpd/conf/httpd.conf
          ServerTokens Prod
          ServerSignature Off
          TraceEnable Off

          <Directory "/var/www/html">
              AllowOverride All
              Options -Indexes +FollowSymLinks
              Require all granted
          </Directory>
          EOF

          chown -R apache:apache /var/www/html
          chmod 755 /var/www/html

          # Restart services to apply all changes
          systemctl enable php-fpm
          systemctl start php-fpm
          systemctl restart php-fpm
          systemctl restart httpd

  PublicInternetRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref PublicInternetVPC
      Tags:
        - Key: Name
          Value: PublicInternet-RTB

  PublicInternetRoute:
    Type: AWS::EC2::Route
    DependsOn: PublicInternetGWAttachment
    Properties:
      RouteTableId: !Ref PublicInternetRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref PublicInternetIGW

  PublicInternetSubnetRTAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicInternetSubnet
      RouteTableId: !Ref PublicInternetRouteTable



# CloudFront Distro Resources

  # IAM Execution Role for Lambda used in the workshop
  LambdaExecutionRole:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: F3
            reason: "* is required in this use case."
          - id: W11
            reason: "* is required in this use case."
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Action: sts:AssumeRole
            Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: SSMCommandAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'ssm:SendCommand'
                  - 'ssm:GetCommandInvocation'
                Resource: '*'

  # CloudFront Origin Access Control to allow CloudFront to invoke Lambda function
  CloudFrontLambdaOAC:
    Type: AWS::CloudFront::OriginAccessControl
    Properties:
      OriginAccessControlConfig:
        Name: CloudFrontLambdaOAC
        OriginAccessControlOriginType: lambda
        SigningBehavior: always
        SigningProtocol: sigv4







  TestScriptDistribution:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W10
            reason: "Workshop use case - access logging not required for test script invocations"
          - id: W70
            reason: "Workshop use case - TLS1.2 is already used by default"
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        CacheBehaviors:
          - TargetOriginId: DevToPRODTesterScript
            PathPattern: /dev-to-prod
            CachePolicyId: 4135ea2d-6df8-44a3-9df3-4b5a84be39ad # managed CachingDisabled
            ViewerProtocolPolicy: allow-all
          - TargetOriginId: OnPremToPRODTesterScript
            PathPattern: /onprem-to-prod
            CachePolicyId: 4135ea2d-6df8-44a3-9df3-4b5a84be39ad # managed CachingDisabled
            ViewerProtocolPolicy: allow-all
          - TargetOriginId: EgressTesterScript
            PathPattern: /egress
            CachePolicyId: 4135ea2d-6df8-44a3-9df3-4b5a84be39ad # managed CachingDisabled
            ViewerProtocolPolicy: allow-all
        DefaultCacheBehavior:
          TargetOriginId: DevToPRODTesterScript
          CachePolicyId: 4135ea2d-6df8-44a3-9df3-4b5a84be39ad # managed CachingDisabled
          ViewerProtocolPolicy: allow-all
        Comment: Building Secure Global Networks Tester Script
        Enabled: true
        HttpVersion: http2and3
        Origins:
          - Id: DevToPRODTesterScript
            DomainName: !Select [0, !Split [/, !Select [1, !Split [//, !GetAtt DevToPRODTesterScriptFunctionURL.FunctionUrl]]]]
            CustomOriginConfig:
              OriginProtocolPolicy: https-only
            OriginAccessControlId: !GetAtt CloudFrontLambdaOAC.Id
          - Id: OnPremToPRODTesterScript
            DomainName: !Select [0, !Split [/, !Select [1, !Split [//, !GetAtt OnPremToPRODTesterScriptFunctionURL.FunctionUrl]]]]
            CustomOriginConfig:
              OriginProtocolPolicy: https-only
            OriginAccessControlId: !GetAtt CloudFrontLambdaOAC.Id
          - Id: EgressTesterScript
            DomainName: !Select [0, !Split [/, !Select [1, !Split [//, !GetAtt EgressTesterScriptFunctionURL.FunctionUrl]]]]
            CustomOriginConfig:
              OriginProtocolPolicy: https-only
            OriginAccessControlId: !GetAtt CloudFrontLambdaOAC.Id


  DevToPRODTesterScriptLogGroup:
    Metadata:
      checkov:
        skip:
          - id: "CKV_AWS_158"
            comment: "Ensure that CloudWatch Log Group is encrypted by KMS"
      cfn_nag:
        rules_to_suppress:
          - id: W84
            reason: "CloudWatch Log Group does not require KMS encryption"
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: "/aws/lambda/dev-to-prod-lambda"
      RetentionInDays: 7

  # Manual Scanner Lambda Function
  DevToPRODTesterScript:
    Metadata:
      checkov:
        skip:
          - id: "CKV_AWS_117"
            comment: "Ensure that AWS Lambda function is configured inside a VPC"
          - id: "CKV_AWS_116"
            comment: "Ensure that AWS Lambda function is configured for a Dead Letter Queue(DLQ)"
          - id: "CKV_AWS_115"
            comment: "Ensure that AWS Lambda function is configured for function-level concurrent execution limit"
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: "Lambda function does not need to be deployed in a VPC"
          - id: W92
            reason: "Lambda function does not need ReservedConcurrentExecutions"
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          from os import environ
          import concurrent.futures
          import boto3
          import time
          from datetime import datetime
          import io
          import sys

          debug_mode = False

          def log_message(message):
              if debug_mode:
                  print(f"[DEBUG][{datetime.now().strftime('%H:%M:%S.%f')}] {message}")

          def execute_tests_in_parallel(tests, ssm_client, test_type):
              with concurrent.futures.ThreadPoolExecutor(max_workers=3) as executor:
                  futures = [
                      executor.submit(
                          execute_ssm_command,
                          ssm_client,
                          test['InstanceId'],
                          test['Command']
                      ) for test in tests
                  ]
                  return [future.result() for future in futures]

          def print_test_result(test, result_string, ret_code):
              test_name = test['Name']
              env_vars = {
                  'sanitized_db_ip': environ['SANITIZED_DB_IP'],
                  'prod_db_ip': environ['PROD_DB_IP'],
                  'prod_web_server': environ['PROD_WEB_SERVER_IP']
              }
              
              sanitized_command = sanitize_command(test['Command'], env_vars)
              request_line = f"Request: {sanitized_command}"
              
              if ret_code == 1 and 'Baseline' in test['Type']:
                  return f'<span class="success">Test Name: {test_name}<span style="display:inline-block; width:50px;"></span>Result: {result_string}</span>\n{request_line}\n<hr>'
              elif ret_code == 0 and 'Baseline' in test['Type']:
                  return f'<span class="fail">Test Name: {test_name}<span style="display:inline-block; width:50px;"></span>Result: {result_string}</span>\n{request_line}\n<hr>'
              elif ret_code == 1 and 'Baseline' not in test['Type']:
                  return f'<span class="fail">Test Name: {test_name}<span style="display:inline-block; width:50px;"></span>Result: {result_string}</span>\n{request_line}\n<hr>'
              elif ret_code == 0 and 'Baseline' not in test['Type']:
                  return f'<span class="success">Test Name: {test_name}<span style="display:inline-block; width:50px;"></span>Result: {result_string}</span>\n{request_line}\n<hr>'
              else:
                  return f'<span class="warning">Test Name: {test_name}<span style="display:inline-block; width:50px;"></span>Result: {result_string}</span>\n{request_line}\n<hr>'

          def execute_ssm_command(ssm_client, instance_id, command):
              try:
                  response = ssm_client.send_command(
                      InstanceIds=[instance_id],
                      DocumentName='AWS-RunShellScript',
                      Parameters={'commands': [command]}
                  )
                  command_id = response['Command']['CommandId']
                  log_message(f"SSM Command ID: {command_id}")

                  max_attempts = 5
                  attempt = 0
                  while attempt < max_attempts:
                      try:
                          output = ssm_client.get_command_invocation(
                              CommandId=command_id,
                              InstanceId=instance_id
                          )
                          
                          if output['Status'] in ['Success', 'Failed', 'Cancelled']:
                              log_message(f"Command completed with status: {output['Status']}")
                              return output['Status'], output.get('StandardOutputContent', ''), output.get('StandardErrorContent', '')
                          
                          time.sleep(1)
                          attempt += 1
                      except ssm_client.exceptions.InvocationDoesNotExist:
                          time.sleep(1)
                          attempt += 1
                          continue

                  return 'Timeout', '', 'Command execution timed out'
              except Exception as e:
                  return 'Failed', '', str(e)

          def parse_result(status, stdout, stderr, command):
              log_message(f"Command status: {status}")
              log_message(f"stdout: '{stdout}'")
              log_message(f"stderr: '{stderr}'")

              # For MySQL connections - check the command itself
              if 'mysql' in command:
                  log_message("MySQL connection detected")
                  # If status is Timeout or Failed, it's blocked
                  if status in ['Timeout', 'Failed']:
                      log_message("Command timed out or failed - blocking connection")
                      return ('Connection Blocked', 0)
                  # Success with '1' means it worked
                  if '1' in stdout:
                      log_message("Found '1' in stdout - allowing connection")
                      return ('Connection Allowed', 1)
                  # If no '1' in output, it's blocked
                  log_message("No '1' in stdout - blocking connection")
                  return ('Connection Blocked', 0)
              
              # For curl connections
              if 'curl' in stdout or stderr:
                  if 'Connection timed out' in stderr or 'Failed to connect' in stderr:
                      return ('Connection Blocked', 0)
                  if '(7)' in stderr or '(28)' in stderr:
                      return ('Connection Blocked', 0)
                  return ('Connection Allowed', 1)
              
              # Default case
              if stdout.strip():
                  return ('Connection Allowed', 1)
              return ('Connection Blocked', 0)

          def parse_ips_filter_result(status, stdout, stderr):
              log_message(f"IPS Filter Test - Status: {status}")
              log_message(f"IPS Filter Test - Stdout: {stdout}")
              log_message(f"IPS Filter Test - Stderr: {stderr}")

              # Check for specific IPS block indicators
              block_indicators = [
                  'Connection refused',
                  'Connection timed out',
                  'Failed to connect',
                  '403 Forbidden',
                  'exit status 28',  # curl timeout
                  'exit status 3',   # curl error
                  'reset by peer'
              ]

              if status != 'Success':
                  return ('Connection Blocked', 0)

              if any(indicator in stderr for indicator in block_indicators):
                  return ('Connection Blocked', 0)

              # If we get a 404, the request got through
              if 'Not Found' in stdout:
                  return ('Connection Allowed', 1)

              # If we get any response, check if it indicates blocking
              if stdout.strip():
                  if any(indicator in stdout for indicator in ['Access Denied', 'Forbidden']):
                      return ('Connection Blocked', 0)
                  return ('Connection Allowed', 1)

              # Default to blocked if we're unsure
              return ('Connection Blocked', 0)

          def sanitize_command(command, env_vars):
              sanitized = command
              replacements = {
                  env_vars['sanitized_db_ip']: '$SANITIZED_PROD_DB',
                  env_vars['prod_db_ip']: '$PROD_DB',
                  env_vars['prod_web_server']: '$INTERNAL_API'
              }
              
              for ip, friendly_name in replacements.items():
                  sanitized = sanitized.replace(ip, friendly_name)
              
              # Convert multiline command to single line for display while preserving spaces
              sanitized = sanitized.replace('\\\n', ' ').replace('                ', ' ')
              
              return sanitized

          def handler(event, context):
              buffer = io.StringIO()
              sys.stdout = buffer

              ssm_client = boto3.client('ssm')

              dev_instance_id = environ['DEV_INSTANCE_ID']
              prod_web_server = environ['PROD_WEB_SERVER_IP']
              sanitized_db_ip = environ['SANITIZED_DB_IP']
              prod_db_ip = environ['PROD_DB_IP']

              baseline_tests = [
                  {
                      'Name': 'DEV resource connecting to sanitized PROD database',
                      'Type': 'Baseline',
                      'InstanceId': dev_instance_id,
                      'Command': f"mysql -N --connect-timeout=1 --wait -h {sanitized_db_ip} -u testuser -p'TestPassword@1234' -e 'SELECT 1;'"
                  },
                  {
                      'Name': 'DEV resource connecting to to PROD internal API',
                      'Type': 'Baseline',
                      'InstanceId': dev_instance_id,
                      'Command': f'curl -s -k --connect-timeout 1 --max-time 2 https://{prod_web_server}'
                  }
              ]
              
              least_privilege_tests = [
                  {
                      'Name': 'DEV resource connecting to main PROD database',
                      'Type': 'LeastPrivilege',
                      'InstanceId': dev_instance_id,
                      'Command': f"mysql -N --connect-timeout=1 --wait -h {prod_db_ip} -u testuser -p'TestPassword@1234' -e 'SELECT 1;'"
                  }
              ]

              ips_filtering_tests = [
                  # Core Security Control Tests
                  {
                      'Name': 'Querying Installed AntiVirus',
                      'Type': 'IPSFilter',
                      'InstanceId': dev_instance_id,
                      'Command': f"curl -s -k --connect-timeout 1 --max-time 2 -H 'Content-Type: text/plain' -d 'Get-CimInstance -ClassName \"AntiVirusProduct\"' 'http://{prod_web_server}/script.ps1'"
                  },
                  {
                      'Name': 'Disable Windows Firewall Snippet',
                      'Type': 'IPSFilter',
                      'InstanceId': dev_instance_id,
                      'Command': f"curl -s -k --connect-timeout 1 --max-time 2 -H 'Content-Type: text/plain' -d 'Set-NetFirewallProfile -Profile Domain,Public,Private -Enabled False' 'http://{prod_web_server}/script.ps1'"
                  },
                  {
                      'Name': 'Byte Array Obfuscation',
                      'Type': 'IPSFilter',
                      'InstanceId': dev_instance_id,
                      'Command': f"curl -s -k --connect-timeout 1 --max-time 2 -H 'Content-Type: text/plain' -d '[Byte[]]$var = 0x48,0x65,0x6c,0x6c,0x6f=(1)' 'http://{prod_web_server}/script.ps1'"
                  },
                  {
                      'Name': 'Get-ClearTextPasswords',
                      'Type': 'IPSFilter',
                      'InstanceId': dev_instance_id,
                      'Command': f"curl -s -k --connect-timeout 1 --max-time 2 -H 'Content-Type: text/plain' -d '[Windows.Security.Credentials.PasswordVault].GetMethod(\"RetrievePassword\").Invoke()' 'http://{prod_web_server}/script.ps1'"
                  },
                  
                  # Environmental Reconnaissance Tests
                  {
                      'Name': 'Domain Controller Credential Dump Script',
                      'Type': 'IPSFilter',
                      'InstanceId': dev_instance_id,
                      'Command': f"curl -s -k --connect-timeout 1 --max-time 2 -H 'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)' -H 'Accept: application/x-powershell' 'http://{prod_web_server}/secrets.ps1'"
                  },
                  {
                      'Name': 'Environment Reconnaissance Script',
                      'Type': 'IPSFilter',
                      'InstanceId': dev_instance_id,
                      'Command': f"curl -s -k --connect-timeout 1 --max-time 2 -H 'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)' -H 'Accept: application/x-powershell' 'http://{prod_web_server}/kirby.ps1'"
                  }
              ]


              print('<h2>DEV to PROD Tests</h2>')
              print('<hr>')

              print('<h3>Baseline Traffic Test</h3>')
              baseline_results = execute_tests_in_parallel(baseline_tests, ssm_client, 'baseline')
              for test, result in zip(baseline_tests, baseline_results):
                  status, stdout, stderr = result
                  result_string, ret_code = parse_result(status, stdout, stderr, test['Command'])
                  output_line = print_test_result(test, result_string, ret_code)
                  print(output_line)

              print('<h3>Least Privilege Network Access Test</h3>')
              least_privilege_results = execute_tests_in_parallel(least_privilege_tests, ssm_client, 'least_privilege')
              for test, result in zip(least_privilege_tests, least_privilege_results):
                  status, stdout, stderr = result
                  result_string, ret_code = parse_result(status, stdout, stderr, test['Command'])
                  output_line = print_test_result(test, result_string, ret_code)
                  print(output_line)

              print('<h3>Intrusion Detection + Prevention (IDS/IPS) Filtering</h3>')
              ips_filtering_results = execute_tests_in_parallel(ips_filtering_tests, ssm_client, 'ips_filtering')
              for test, result in zip(ips_filtering_tests, ips_filtering_results):
                  status, stdout, stderr = result
                  result_string, ret_code = parse_ips_filter_result(status, stdout, stderr)
                  output_line = print_test_result(test, result_string, ret_code)
                  print(output_line)

              output = buffer.getvalue()
              sys.stdout = sys.__stdout__

              css_styles = """
              <style>
                  .success { color: green; }
                  .fail { color: red; }
                  .warning { color: orange; }
                  hr { border: 1px solid black; }
                  pre { white-space: pre-wrap; word-wrap: break-word; }
                  h3 { margin-top: 20px; margin-bottom: 10px; }
              </style>
              """

              body = css_styles + '<pre>' + output + '</pre>'
              
              return {
                  'statusCode': 200,
                  'body': body,
                  'headers': {
                      'Content-Type': 'text/html'
                  }
              }
      FunctionName: DEV-To-PROD
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.12
      MemorySize: 4096
      Timeout: 60
      LoggingConfig:
        LogGroup: !Ref DevToPRODTesterScriptLogGroup 
      Environment:
        Variables:
          DEV_INSTANCE_ID: !GetAtt DevVPC1WorkloadInstance1.InstanceId
          PROD_INSTANCE_ID: !GetAtt ProdVPC1WorkloadInstance1.InstanceId
          ONPREM_INSTANCE_ID: "INSERT-ON-PREM-INSTANCE-ID"
          PROD_WEB_SERVER_IP: !GetAtt ProdVPC1WorkloadInstance1.PrivateIp
          SANITIZED_DB_IP: !GetAtt ProdVPC1WorkloadInstance3.PrivateIp
          PROD_DB_IP: !GetAtt ProdVPC1WorkloadInstance2.PrivateIp
          PUBLIC_INTERNET_HOST_IP: !GetAtt PublicInternetHost.PublicIp


  # Lambda function URL for manual scanner function
  DevToPRODTesterScriptFunctionURL:
    Type: AWS::Lambda::Url
    Properties:
      AuthType: AWS_IAM
      TargetFunctionArn: !GetAtt DevToPRODTesterScript.Arn

  # Allow Manual Scanner Lambda to be invoked from CloudFront via OAC
  DevToPRODTesterScriptPermissionPolicy:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W24
            reason: "Policy is required"
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunctionUrl
      FunctionName: !Ref DevToPRODTesterScript
      Principal: cloudfront.amazonaws.com
      SourceArn: !Sub arn:${AWS::Partition}:cloudfront::${AWS::AccountId}:distribution/${TestScriptDistribution}

  OnPremToPRODTesterScriptLogGroup:
    Metadata:
      checkov:
        skip:
          - id: "CKV_AWS_158"
            comment: "Ensure that CloudWatch Log Group is encrypted by KMS"
      cfn_nag:
        rules_to_suppress:
          - id: W84
            reason: "CloudWatch Log Group does not require KMS encryption"
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: "/aws/lambda/onprem-to-prod-lambda"
      RetentionInDays: 7


  OnPremToPRODTesterScript:
    Metadata:
      checkov:
        skip:
          - id: "CKV_AWS_117"
            comment: "Ensure that AWS Lambda function is configured inside a VPC"
          - id: "CKV_AWS_116"
            comment: "Ensure that AWS Lambda function is configured for a Dead Letter Queue(DLQ)"
          - id: "CKV_AWS_115"
            comment: "Ensure that AWS Lambda function is configured for function-level concurrent execution limit"
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: "Lambda function does not need to be deployed in a VPC"
          - id: W92
            reason: "Lambda function does not need ReservedConcurrentExecutions"
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          from os import environ
          import concurrent.futures
          import boto3
          import time
          from datetime import datetime
          import io
          import sys

          debug_mode = False

          def log_message(message):
              if debug_mode:
                  print(f"[DEBUG][{datetime.now().strftime('%H:%M:%S.%f')}] {message}")

          def execute_tests_in_parallel(tests, ssm_client, test_type):
              with concurrent.futures.ThreadPoolExecutor(max_workers=3) as executor:
                  futures = [
                      executor.submit(
                          execute_ssm_command,
                          ssm_client,
                          test['InstanceId'],
                          test['Command']
                      ) for test in tests
                  ]
                  return [future.result() for future in futures]

          def print_test_result(test, result_string, ret_code):
              test_name = test['Name']
              env_vars = {
                  'sanitized_db_ip': environ['SANITIZED_DB_IP'],
                  'prod_db_ip': environ['PROD_DB_IP'],
                  'prod_web_server': environ['PROD_WEB_SERVER_IP']
              }
              
              sanitized_command = sanitize_command(test['Command'], env_vars)
              request_line = f"Request: {sanitized_command}"
              
              if ret_code == 1 and 'Baseline' in test['Type']:
                  return f'<span class="success">Test Name: {test_name}<span style="display:inline-block; width:50px;"></span>Result: {result_string}</span>\n{request_line}\n<hr>'
              elif ret_code == 0 and 'Baseline' in test['Type']:
                  return f'<span class="fail">Test Name: {test_name}<span style="display:inline-block; width:50px;"></span>Result: {result_string}</span>\n{request_line}\n<hr>'
              elif ret_code == 1 and 'Baseline' not in test['Type']:
                  return f'<span class="fail">Test Name: {test_name}<span style="display:inline-block; width:50px;"></span>Result: {result_string}</span>\n{request_line}\n<hr>'
              elif ret_code == 0 and 'Baseline' not in test['Type']:
                  return f'<span class="success">Test Name: {test_name}<span style="display:inline-block; width:50px;"></span>Result: {result_string}</span>\n{request_line}\n<hr>'
              else:
                  return f'<span class="warning">Test Name: {test_name}<span style="display:inline-block; width:50px;"></span>Result: {result_string}</span>\n{request_line}\n<hr>'

          def execute_ssm_command(ssm_client, instance_id, command):
              try:
                  response = ssm_client.send_command(
                      InstanceIds=[instance_id],
                      DocumentName='AWS-RunShellScript',
                      Parameters={'commands': [command]}
                  )
                  command_id = response['Command']['CommandId']
                  log_message(f"SSM Command ID: {command_id}")

                  max_attempts = 5
                  attempt = 0
                  while attempt < max_attempts:
                      try:
                          output = ssm_client.get_command_invocation(
                              CommandId=command_id,
                              InstanceId=instance_id
                          )
                          
                          if output['Status'] in ['Success', 'Failed', 'Cancelled']:
                              log_message(f"Command completed with status: {output['Status']}")
                              return output['Status'], output.get('StandardOutputContent', ''), output.get('StandardErrorContent', '')
                          
                          time.sleep(1)
                          attempt += 1
                      except ssm_client.exceptions.InvocationDoesNotExist:
                          time.sleep(1)
                          attempt += 1
                          continue

                  return 'Timeout', '', 'Command execution timed out'
              except Exception as e:
                  return 'Failed', '', str(e)

          def parse_result(status, stdout, stderr, command):
              log_message(f"Command status: {status}")
              log_message(f"stdout: '{stdout}'")
              log_message(f"stderr: '{stderr}'")

              # For MySQL connections - check the command itself
              if 'mysql' in command:
                  log_message("MySQL connection detected")
                  # If status is Timeout or Failed, it's blocked
                  if status in ['Timeout', 'Failed']:
                      log_message("Command timed out or failed - blocking connection")
                      return ('Connection Blocked', 0)
                  # Success with '1' means it worked
                  if '1' in stdout:
                      log_message("Found '1' in stdout - allowing connection")
                      return ('Connection Allowed', 1)
                  # If no '1' in output, it's blocked
                  log_message("No '1' in stdout - blocking connection")
                  return ('Connection Blocked', 0)
              
              # For curl connections
              if 'curl' in command:  # Changed from checking stdout/stderr to checking command
                  # Check for specific failure indicators
                  curl_failure_indicators = [
                      'Connection timed out',
                      'Failed to connect',
                      'Could not resolve host',
                      'exit status 28',  # curl timeout
                      'exit status 7',   # curl connect error
                      'exit status 6',   # could not resolve host
                  ]
                  
                  # If status is Failed or we see any failure indicators, connection is blocked
                  if status == 'Failed' or any(indicator in stderr for indicator in curl_failure_indicators):
                      return ('Connection Blocked', 0)
                  
                  # If we got any response (even empty), consider it allowed
                  # This is because a successful curl with no output is still a connection
                  if status == 'Success':
                      return ('Connection Blocked', 0) if not stdout and not stderr else ('Connection Allowed', 1)
              
              # Default case
              if stdout.strip():
                  return ('Connection Allowed', 1)
              return ('Connection Blocked', 0)

          def parse_ips_filter_result(status, stdout, stderr):
              log_message(f"IPS Filter Test - Status: {status}")
              log_message(f"IPS Filter Test - Stdout: {stdout}")
              log_message(f"IPS Filter Test - Stderr: {stderr}")

              # If we get a successful response with our payload in it, the attack was allowed
              if status == 'Success' and 'jform' in stdout:
                  return ('Connection Allowed', 1)
              
              # If we get connection refused, timeout, or other error, it was blocked
              if status != 'Success' or 'Connection refused' in stderr or 'Connection timed out' in stderr:
                  return ('Connection Blocked', 0)
              
              # Default case
              return ('Connection Allowed', 1)

          def sanitize_command(command, env_vars):
              sanitized = command
              replacements = {
                  env_vars['sanitized_db_ip']: '$SANITIZED_PROD_DB',
                  env_vars['prod_db_ip']: '$PROD_DB',
                  env_vars['prod_web_server']: '$INTERNAL_API'
              }
              
              for ip, friendly_name in replacements.items():
                  sanitized = sanitized.replace(ip, friendly_name)
              
              # Convert multiline command to single line for display while preserving spaces
              sanitized = sanitized.replace('\\\n', ' ').replace('                ', ' ')
              
              return sanitized

          def handler(event, context):
              buffer = io.StringIO()
              sys.stdout = buffer

              # Change SSM client initialization
              ssm_client = boto3.client('ssm', region_name='eu-central-1')

              # Update environment variables section
              onprem_instance_id = environ['ONPREM_INSTANCE_ID']
              prod_web_server = environ['PROD_WEB_SERVER_IP']
              sanitized_db_ip = environ['SANITIZED_DB_IP']
              prod_db_ip = environ['PROD_DB_IP']

              baseline_tests = [
                  {
                      'Name': 'OnPrem resource connecting to sanitized PROD database',
                      'Type': 'Baseline',
                      'InstanceId': onprem_instance_id,
                      'Command': f"mysql -N --connect-timeout=1 --wait -h {sanitized_db_ip} -u testuser -p'TestPassword@1234' -e 'SELECT 1;'"
                  },
                  {
                      'Name': 'OnPrem resource connecting to PROD internal API',
                      'Type': 'Baseline',
                      'InstanceId': onprem_instance_id,
                      'Command': f'curl -s -k --connect-timeout 1 --max-time 2 https://{prod_web_server}'
                  }
              ]
              
              least_privilege_tests = [
                  {
                      'Name': 'OnPrem resource connecting to main PROD database',
                      'Type': 'LeastPrivilege',
                      'InstanceId': onprem_instance_id,
                      'Command': f"mysql -N --connect-timeout=1 --wait -h {prod_db_ip} -u testuser -p'TestPassword@1234' -e 'SELECT 1;'"
                  }
              ]

              ips_filtering_tests = [
                  {
                      'Name': 'Joomla CMS ACL Privilege Escalation Test (CVE-2020-35616)',
                      'Type': 'IPSFilter',
                      'InstanceId': onprem_instance_id,
                      'Command': (
                          f"curl -s -k --connect-timeout 1 --max-time 2 "
                          f"-X POST "
                          f"-H 'Content-Type: application/x-www-form-urlencoded' "
                          f"-d 'test=1&jform%5Brules%5D%5Bcore.test%5D%5B2%5D=1&jform%5Brules%5D%5Bcore.other%5D=1' "
                          f"'http://{prod_web_server}/administrator/index.php?option='"
                      )
                  },
                  {
                      'Name': 'FreePBX Authentication Bypass Test (CVE-2019-19006)',
                      'Type': 'IPSFilter',
                      'InstanceId': onprem_instance_id,
                      'Command': (
                          f"curl -s -k --connect-timeout 1 --max-time 2 "
                          f"'http://{prod_web_server}/admin/config.php?password%5B0%5D=anything&username=admin'"
                      )
                  }
              ]


              print('<h2>OnPrem to PROD Tests</h2>')
              print('<hr>')

              print('<h3>Baseline Traffic Test</h3>')
              baseline_results = execute_tests_in_parallel(baseline_tests, ssm_client, 'baseline')
              for test, result in zip(baseline_tests, baseline_results):
                  status, stdout, stderr = result
                  result_string, ret_code = parse_result(status, stdout, stderr, test['Command'])
                  output_line = print_test_result(test, result_string, ret_code)
                  print(output_line)

              print('<h3>Least Privilege Network Access Test</h3>')
              least_privilege_results = execute_tests_in_parallel(least_privilege_tests, ssm_client, 'least_privilege')
              for test, result in zip(least_privilege_tests, least_privilege_results):
                  status, stdout, stderr = result
                  result_string, ret_code = parse_result(status, stdout, stderr, test['Command'])
                  output_line = print_test_result(test, result_string, ret_code)
                  print(output_line)

              print('<h3>Intrusion Detection + Prevention (IDS/IPS) Filtering</h3>')
              ips_filtering_results = execute_tests_in_parallel(ips_filtering_tests, ssm_client, 'ips_filtering')
              for test, result in zip(ips_filtering_tests, ips_filtering_results):
                  status, stdout, stderr = result
                  result_string, ret_code = parse_ips_filter_result(status, stdout, stderr)
                  output_line = print_test_result(test, result_string, ret_code)
                  print(output_line)

              output = buffer.getvalue()
              sys.stdout = sys.__stdout__

              css_styles = """
              <style>
                  .success { color: green; }
                  .fail { color: red; }
                  .warning { color: orange; }
                  hr { border: 1px solid black; }
                  pre { white-space: pre-wrap; word-wrap: break-word; }
                  h3 { margin-top: 20px; margin-bottom: 10px; }
              </style>
              """

              body = css_styles + '<pre>' + output + '</pre>'
              
              return {
                  'statusCode': 200,
                  'body': body,
                  'headers': {
                      'Content-Type': 'text/html'
                  }
              }
      FunctionName: OnPrem-To-PROD
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.12
      MemorySize: 4096
      Timeout: 60
      LoggingConfig:
        LogGroup: !Ref OnPremToPRODTesterScriptLogGroup 
      Environment:
        Variables:
          DEV_INSTANCE_ID: !GetAtt DevVPC1WorkloadInstance1.InstanceId
          PROD_INSTANCE_ID: !GetAtt ProdVPC1WorkloadInstance1.InstanceId
          ONPREM_INSTANCE_ID: "INSERT-ON-PREM-INSTANCE-ID"
          PROD_WEB_SERVER_IP: !GetAtt ProdVPC1WorkloadInstance1.PrivateIp
          SANITIZED_DB_IP: !GetAtt ProdVPC1WorkloadInstance3.PrivateIp
          PROD_DB_IP: !GetAtt ProdVPC1WorkloadInstance2.PrivateIp
          PUBLIC_INTERNET_HOST_IP: !GetAtt PublicInternetHost.PublicIp


  # Lambda function URL for manual scanner function
  OnPremToPRODTesterScriptFunctionURL:
    Type: AWS::Lambda::Url
    Properties:
      AuthType: AWS_IAM
      TargetFunctionArn: !GetAtt OnPremToPRODTesterScript.Arn

  # Allow Manual Scanner Lambda to be invoked from CloudFront via OAC
  OnPremToPRODTesterScriptPermissionPolicy:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W24
            reason: "Policy is required"
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunctionUrl
      FunctionName: !Ref OnPremToPRODTesterScript
      Principal: cloudfront.amazonaws.com
      SourceArn: !Sub arn:${AWS::Partition}:cloudfront::${AWS::AccountId}:distribution/${TestScriptDistribution}

  EgressTesterScriptLogGroup:
    Metadata:
      checkov:
        skip:
          - id: "CKV_AWS_158"
            comment: "Ensure that CloudWatch Log Group is encrypted by KMS"
      cfn_nag:
        rules_to_suppress:
          - id: W84
            reason: "CloudWatch Log Group does not require KMS encryption"
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: "/aws/lambda/egress-test-lambda-logs"
      RetentionInDays: 7


  # Manual Scanner Lambda Function
  EgressTesterScript:
    Metadata:
      checkov:
        skip:
          - id: "CKV_AWS_117"
            comment: "Ensure that AWS Lambda function is configured inside a VPC"
          - id: "CKV_AWS_116"
            comment: "Ensure that AWS Lambda function is configured for a Dead Letter Queue(DLQ)"
          - id: "CKV_AWS_115"
            comment: "Ensure that AWS Lambda function is configured for function-level concurrent execution limit"
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: "Lambda function does not need to be deployed in a VPC"
          - id: W92
            reason: "Lambda function does not need ReservedConcurrentExecutions"
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          from os import environ
          import concurrent.futures
          import boto3
          import time
          from datetime import datetime
          import io
          import sys

          debug_mode = False

          def log_message(message):
              if debug_mode:
                  print(f"[DEBUG][{datetime.now().strftime('%H:%M:%S')}] {message}")

          def execute_tests_in_parallel(tests, ssm_client, test_type):
              with concurrent.futures.ThreadPoolExecutor(max_workers=3) as executor:
                  futures = [
                      executor.submit(
                          execute_ssm_command if test_type != 'egress' else execute_egress_test,
                          ssm_client,
                          test['InstanceId'],
                          test['Command']
                      ) for test in tests
                  ]
                  return [future.result() for future in futures]

          def execute_ssm_command(ssm_client, instance_id, command):
              try:
                  response = ssm_client.send_command(
                      InstanceIds=[instance_id],
                      DocumentName='AWS-RunShellScript',
                      Parameters={'commands': [command]}
                  )
                  command_id = response['Command']['CommandId']

                  max_attempts = 5
                  attempt = 0
                  while attempt < max_attempts:
                      try:
                          output = ssm_client.get_command_invocation(
                              CommandId=command_id,
                              InstanceId=instance_id
                          )
                          
                          if output['Status'] in ['Success', 'Failed', 'Cancelled']:
                              return output['Status'], output.get('StandardOutputContent', ''), output.get('StandardErrorContent', '')
                          
                          time.sleep(1)
                          attempt += 1
                      except ssm_client.exceptions.InvocationDoesNotExist:
                          time.sleep(1)
                          attempt += 1
                          continue

                  return 'Timeout', '', 'Command execution timed out'
              except Exception as e:
                  log_message(f"ERROR: {str(e)}")
                  return 'Failed', '', str(e)
              
          def execute_all_tests_in_parallel(tests, ssm_client, test_type, dev_instance_id, prod_instance_id):
              with concurrent.futures.ThreadPoolExecutor(max_workers=6) as executor:  # Increased for true parallelism
                  futures = []
                  for test in tests:
                      # Submit DEV test
                      dev_test = test.copy()
                      dev_test['InstanceId'] = dev_instance_id
                      futures.append((test['Name'], 'DEV', executor.submit(
                          execute_ssm_command if test_type != 'egress' else execute_egress_test,
                          ssm_client,
                          dev_instance_id,
                          test['Command']
                      )))
                      
                      # Submit PROD test
                      prod_test = test.copy()
                      prod_test['InstanceId'] = prod_instance_id
                      futures.append((test['Name'], 'PROD', executor.submit(
                          execute_ssm_command if test_type != 'egress' else execute_egress_test,
                          ssm_client,
                          prod_instance_id,
                          test['Command']
                      )))
                  
                  # Create a dict to store results
                  results = {}
                  for name, env, future in futures:
                      try:
                          result = future.result()
                          if name not in results:
                              results[name] = {'DEV': None, 'PROD': None}
                          results[name][env] = result
                      except Exception as e:
                          log_message(f"ERROR in {name} - {env}: {str(e)}")
                          
                  return results

          def parse_result(status, stdout, stderr, test_type):
              log_message(f"=== Test Details ===")
              log_message(f"Test type: {test_type}")
              log_message(f"Status: {status}")
              log_message(f"stdout: {stdout}")
              log_message(f"stderr: {stderr}")

              # For IPS filtering tests
              if test_type == 'IPSFilter':
                  # Common block indicators
                  block_indicators = [
                      'Operation timed out',
                      'Connection refused',
                      'Failed to connect',
                      '403 Forbidden',
                      'Unable to connect',
                      'reset by peer',
                      'Empty reply from server'
                  ]

                  # Check if the connection was blocked
                  connection_blocked = (
                      status == 'Timeout' or
                      any(indicator in stdout or indicator in stderr for indicator in block_indicators)
                  )

                  # Special handling for binary download test with MultiMiner user agent
                  if 'MultiMiner/V' in stdout:
                      log_message("Processing MultiMiner user agent test...")
                      if 'Operation timed out' in stdout or connection_blocked:
                          log_message("IPS Filter: MultiMiner request blocked")
                          return ('Connection Blocked', 1)
                      log_message("IPS Filter: MultiMiner request allowed")
                      return ('Connection Allowed', 0)
                      
                  elif '/cpu64.exe' in stdout:
                      log_message("Processing binary download test...")
                      if 'Operation timed out' in stdout or connection_blocked:
                          log_message("IPS Filter: Binary download blocked")
                          return ('Connection Blocked', 1)
                      log_message("IPS Filter: Binary download allowed")
                      return ('Connection Allowed', 0)
                      
                  elif '/pool.config' in stdout or 'XMRig' in stdout:
                      log_message("Processing mining pool config test...")
                      if connection_blocked or 'denied' in stdout.lower():
                          log_message("IPS Filter: Mining pool config blocked")
                          return ('Connection Blocked', 1)
                      elif 'pool.monero.hashvault.pro' in stdout:
                          log_message("IPS Filter: Mining pool config allowed")
                          return ('Connection Allowed', 0)
                      log_message("IPS Filter: Mining pool config blocked (no valid response)")
                      return ('Connection Blocked', 1)
                  
                  elif '/pool' in stdout:
                      log_message("Processing C2 communication test...")
                      if connection_blocked:
                          log_message("IPS Filter: C2 communication blocked")
                          return ('Connection Blocked', 1)
                      elif 'HTTP/1.1 301' in stdout or 'HTTP/1.1 200' in stdout:
                          log_message("IPS Filter: C2 communication allowed")
                          return ('Connection Allowed', 0)
                      log_message("IPS Filter: C2 communication blocked (no valid response)")
                      return ('Connection Blocked', 1)

              # For baseline tests
              elif test_type == 'Baseline':
                  if stdout.strip() or 'HTTP/1.1 200 OK' in stderr:
                      log_message("Baseline: Connection allowed")
                      return ('Connection Allowed', 1)
                  log_message("Baseline: Connection blocked")
                  return ('Connection Blocked', 0)

              # For egress tests
              elif test_type == 'Egress':
                  if stdout.strip() == 'BLOCKED':
                      log_message("Egress: Connection blocked")
                      return ('Blocked', 0)
                  elif stdout.strip() == 'ALLOWED':
                      log_message("Egress: Connection allowed")
                      return ('Allowed', 1)
                  
                  # If the output doesn't contain BLOCKED or ALLOWED, we'll do additional checks
                  if 'dig' in stdout or stderr:
                      if 'controldomain1.aggregatelist.firewall.route53resolver.us-east-1.amazonaws.com' in stdout:
                          if '1.2.3.4' in stdout:
                              log_message("Egress: AWS Threat List DNS query allowed")
                              return ('Allowed', 1)
                          else:
                              log_message("Egress: AWS Threat List DNS query blocked")
                              return ('Blocked', 0)
                      # Handle other dig commands
                      elif 'NXDOMAIN' in stdout or 'connection timed out' in stdout or 'no servers could be reached' in stdout:
                          log_message("Egress: DNS query blocked")
                          return ('Blocked', 0)
                      elif ';; ANSWER SECTION:' in stdout:
                          log_message("Egress: DNS query allowed")
                          return ('Allowed', 1)
                      else:
                          log_message("Egress: DNS query result unclear")
                          return ('Unknown', 0)
                  
                  if 'ping' in stdout:
                      if '0 received' in stdout or 'Destination Host Unreachable' in stdout:
                          log_message("Egress: Ping blocked")
                          return ('Blocked', 0)
                      log_message("Egress: Ping allowed")
                      return ('Allowed', 1)

              # Default case
              if status != 'Success':
                  log_message("Default: Connection blocked (status not Success)")
                  return ('Connection Blocked', 0)
              log_message("Default: Connection allowed")
              return ('Connection Allowed', 1)


          def print_test_result(test, dev_result, prod_result):
              test_name = test['Name']
              env_vars = {
                  'PUBLIC_INTERNET_HOST_IP': environ['PUBLIC_INTERNET_HOST_IP']
              }
              
              sanitized_command = sanitize_command(test['Command'], env_vars)
              request_line = f"Request: {sanitized_command}"
              
              log_message(f"Dev Result: {dev_result}")
              log_message(f"Prod Result: {prod_result}")
              
              # Handle different test types
              if 'Baseline' in test['Type']:
                  # For Baseline tests: 1 = success (green), 0 = failure (red)
                  dev_result_str = f'<span class="success">Connection Allowed from DEV</span>' if dev_result[1] == 1 else f'<span class="fail">Connection Blocked from DEV</span>'
                  prod_result_str = f'<span class="success">Connection Allowed from PROD</span>' if prod_result[1] == 1 else f'<span class="fail">Connection Blocked from PROD</span>'
                  line_color = "success" if dev_result[1] == 1 or prod_result[1] == 1 else "fail"
              
              elif test['Type'] == 'IPSFilter':
                  # For IPS tests: 0 = allowed (red), 1 = blocked (green)
                  dev_result_str = f'<span class="fail">Connection Allowed from DEV</span>' if dev_result[1] == 0 else f'<span class="success">Connection Blocked from DEV</span>'
                  prod_result_str = f'<span class="fail">Connection Allowed from PROD</span>' if prod_result[1] == 0 else f'<span class="success">Connection Blocked from PROD</span>'
                  line_color = "success" if (dev_result[1] == 1 and prod_result[1] == 1) else "fail"
              
              elif test['Type'] == 'Egress':
                  # For Egress tests: 1 = allowed (red), 0 = blocked (green)
                  dev_result_str = f'<span class="fail">Connection Allowed from DEV</span>' if dev_result[1] == 1 else f'<span class="success">Connection Blocked from DEV</span>'
                  prod_result_str = f'<span class="fail">Connection Allowed from PROD</span>' if prod_result[1] == 1 else f'<span class="success">Connection Blocked from PROD</span>'
                  line_color = "success" if (dev_result[1] == 0 and prod_result[1] == 0) else "fail"
              
              # Format the full line with proper spacing and consistent coloring
              return f'<span class="{line_color}">{test_name}<span style="display:inline-block; width:50px;"></span>Result:</span> {dev_result_str} | {prod_result_str}\n{request_line}\n<hr>'


          def sanitize_command(command, env_vars):
              sanitized = command
              for key, value in env_vars.items():
                  if key == 'PUBLIC_INTERNET_HOST_IP':
                      sanitized = sanitized.replace(value, '$PUBLIC_INTERNET_HOST')
                  else:
                      sanitized = sanitized.replace(value, key)
              return sanitized

          def get_wrapper_for_test(command):
              """Wrapper for egress test commands"""
              if command.startswith("dig"):
                  if "aggregatelist.firewall.route53resolver" in command:
                      return f"""
                          RESULT=$(timeout 3 {command})
                          if [[ $RESULT == *"1.2.3.4"* ]]; then
                              echo "ALLOWED"
                          else
                              echo "BLOCKED"
                          fi
                      """
                  else:
                      return f"""
                          RESULT=$(timeout 3 {command})
                          if [[ $? -eq 124 ]] || [[ $RESULT == *"connection timed out"* ]] || [[ $RESULT == *"no servers could be reached"* ]]; then
                              echo "BLOCKED"
                          else
                              echo "ALLOWED"
                          fi
                      """
              elif command.startswith("ping"):
                  return f"""
                      RESULT=$(timeout 2 {command})
                      if [[ $RESULT == *"0 received"* ]] || [[ $RESULT == *"Destination Host Unreachable"* ]]; then
                          echo "BLOCKED"
                      else
                          echo "ALLOWED"
                      fi
                  """
              elif command.startswith("curl"):
                  return f"""
                      RESPONSE=$(timeout 2 {command})
                      HTTP_CODE=$?
                      if [ $HTTP_CODE -eq 0 ]; then
                          echo "ALLOWED"
                      else
                          echo "BLOCKED"
                      fi
                  """
              elif command.startswith("ssh"):
                  return f"""
                      RESULT=$(timeout 2 {command} 2>&1)
                      if [[ $RESULT == *"Permission denied"* ]]; then
                          echo "ALLOWED"
                      elif [[ $RESULT == *"Connection timed out"* ]] || [[ $RESULT == *"Connection refused"* ]]; then
                          echo "BLOCKED"
                      else
                          echo "BLOCKED"
                      fi
                  """
              return command

          def execute_egress_test(ssm_client, instance_id, command):
              wrapped_command = get_wrapper_for_test(command)
              return execute_ssm_command(ssm_client, instance_id, wrapped_command)


          def handler(event, context):
              buffer = io.StringIO()
              sys.stdout = buffer

              ssm_client = boto3.client('ssm')
              dev_instance_id = environ['DEV_INSTANCE_ID']
              prod_instance_id = environ['PROD_INSTANCE_ID']
              public_internet_host_ip = environ['PUBLIC_INTERNET_HOST_IP']

              # Define all tests without instance IDs
              baseline_tests = [
                  {
                      'Name': 'Internet Access - GitHub',
                      'Type': 'Baseline',
                      'Command': "curl -s -k --connect-timeout 1 --max-time 1 https://github.com"
                  },
                  {
                      'Name': 'Internet Access - Example.com',
                      'Type': 'Baseline',
                      'Command': "curl -s -k --connect-timeout 1 --max-time 1 http://example.com"
                  }
              ]

              # Combined egress and IPS filtering tests in the specified order
              egress_tests = [
                  {
                      'Name': 'Route 53 Resolver DNS Firewall Aggregate Threat List',
                      'Type': 'Egress',
                      'Command': "dig controldomain1.aggregatelist.firewall.route53resolver.us-east-1.amazonaws.com"
                  },
                  {
                      'Name': 'Route 53 Resolver DNS Firewall Bypass Attempt',
                      'Type': 'Egress',
                      'Command': "dig @8.8.8.8 +timeout=1 www.google.com"
                  },
                  {
                      'Name': 'Network Firewall Port/Protocol Enforcement - HTTP over non-standard port',
                      'Type': 'Egress',
                      'Command': f"curl -s -k --connect-timeout 1 --max-time 1 'http://{public_internet_host_ip}:4444'"
                  },
                  {
                      'Name': 'Network Firewall Port/Protocol Enforcement - SSH over port 443',
                      'Type': 'Egress',
                      'Command': f"ssh -p 443 -o StrictHostKeyChecking=no -o ConnectTimeout=2 -o UserKnownHostsFile=/dev/null -o PasswordAuthentication=no -v ec2-user@{public_internet_host_ip}"
                  },
                  {
                      'Name': 'Cryptominer Binary Download',
                      'Type': 'IPSFilter',
                      'Command': f"curl -s -k --connect-timeout 1 --max-time 1 -i 'http://{public_internet_host_ip}/cpu64.exe' -v 2>&1 || true"
                  },
                  {
                      'Name': 'Observed MultiMiner User-Agent',
                      'Type': 'IPSFilter',
                      'Command': f"curl -s -k --connect-timeout 1 --max-time 1 -H 'User-Agent: MultiMiner/V2.0' -i 'http://{public_internet_host_ip}/cpu64.exe' -v 2>&1 || true"
                  }
              ]

              print('<h2>Egress Security Tests</h2>')
              print('<hr>')

              # Process Baseline Tests
              print('<h3>Baseline Traffic Tests</h3>')
              baseline_results = execute_all_tests_in_parallel(baseline_tests, ssm_client, 'baseline', dev_instance_id, prod_instance_id)
              for test in baseline_tests:
                  log_message(f"Starting test: {test['Name']}")
                  
                  dev_status, dev_stdout, dev_stderr = baseline_results[test['Name']]['DEV']
                  prod_status, prod_stdout, prod_stderr = baseline_results[test['Name']]['PROD']
                  
                  dev_result = parse_result(dev_status, dev_stdout, dev_stderr, test['Type'])
                  prod_result = parse_result(prod_status, prod_stdout, prod_stderr, test['Type'])
                  
                  log_message(f"Test completed: {test['Name']}")
                  output_line = print_test_result(test, dev_result, prod_result)
                  print(output_line)

              # Split tests by type but display under the same heading
              print('<h3>Egress Security Tests</h3>')
              
              # Extract egress and IPS tests
              egress_only_tests = [test for test in egress_tests if test['Type'] == 'Egress']
              ips_only_tests = [test for test in egress_tests if test['Type'] == 'IPSFilter']
              
              # Process egress tests
              egress_results = execute_all_tests_in_parallel(egress_only_tests, ssm_client, 'egress', dev_instance_id, prod_instance_id)
              for test in egress_only_tests:
                  log_message(f"Starting test: {test['Name']}")
                  
                  dev_status, dev_stdout, dev_stderr = egress_results[test['Name']]['DEV']
                  prod_status, prod_stdout, prod_stderr = egress_results[test['Name']]['PROD']
                  
                  dev_result = parse_result(dev_status, dev_stdout, dev_stderr, test['Type'])
                  prod_result = parse_result(prod_status, prod_stdout, prod_stderr, test['Type'])
                  
                  log_message(f"Test completed: {test['Name']}")
                  output_line = print_test_result(test, dev_result, prod_result)
                  print(output_line)
              
              # Process IPS tests
              ips_results = execute_all_tests_in_parallel(ips_only_tests, ssm_client, 'ips_filtering', dev_instance_id, prod_instance_id)
              for test in ips_only_tests:
                  log_message(f"Starting test: {test['Name']}")
                  
                  dev_status, dev_stdout, dev_stderr = ips_results[test['Name']]['DEV']
                  prod_status, prod_stdout, prod_stderr = ips_results[test['Name']]['PROD']
                  
                  dev_result = parse_result(dev_status, dev_stdout, dev_stderr, test['Type'])
                  prod_result = parse_result(prod_status, prod_stdout, prod_stderr, test['Type'])
                  
                  log_message(f"Test completed: {test['Name']}")
                  output_line = print_test_result(test, dev_result, prod_result)
                  print(output_line)


              output = buffer.getvalue()
              sys.stdout = sys.__stdout__

              css_styles = """
              <style>
                  .success { color: green; }
                  .fail { color: red; }
                  .warning { color: orange; }
                  .normal { color: black; }
                  hr { border: 1px solid black; }
                  pre { white-space: pre-wrap; word-wrap: break-word; }
                  h3 { margin-top: 20px; margin-bottom: 10px; }
              </style>
              """

              body = css_styles + '<pre>' + output + '</pre>'
              
              return {
                  'statusCode': 200,
                  'body': body,
                  'headers': {
                      'Content-Type': 'text/html'
                  }
              }
      FunctionName: Egress-Tests
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.12
      MemorySize: 4096
      Timeout: 60
      LoggingConfig:
        LogGroup: !Ref EgressTesterScriptLogGroup 
      Environment:
        Variables:
          DEV_INSTANCE_ID: !GetAtt DevVPC1WorkloadInstance1.InstanceId
          PROD_INSTANCE_ID: !GetAtt ProdVPC1WorkloadInstance1.InstanceId
          ONPREM_INSTANCE_ID: "INSERT-ON-PREM-INSTANCE-ID"
          PROD_WEB_SERVER_IP: !GetAtt ProdVPC1WorkloadInstance1.PrivateIp
          SANITIZED_DB_IP: !GetAtt ProdVPC1WorkloadInstance3.PrivateIp
          PROD_DB_IP: !GetAtt ProdVPC1WorkloadInstance2.PrivateIp
          PUBLIC_INTERNET_HOST_IP: !GetAtt PublicInternetHost.PublicIp

  # Lambda function URL for manual scanner function
  EgressTesterScriptFunctionURL:
    Type: AWS::Lambda::Url
    Properties:
      AuthType: AWS_IAM
      TargetFunctionArn: !GetAtt EgressTesterScript.Arn

  # Allow Manual Scanner Lambda to be invoked from CloudFront via OAC
  EgressTesterScriptPermissionPolicy:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W24
            reason: "Policy is required"
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunctionUrl
      FunctionName: !Ref EgressTesterScript
      Principal: cloudfront.amazonaws.com
      SourceArn: !Sub arn:${AWS::Partition}:cloudfront::${AWS::AccountId}:distribution/${TestScriptDistribution}




# CloudWatch Dashboard Resources
  ##### Custom Resource #####

  GenerateSubnetQueryStringFunctionLogGroup:
    Metadata:
      checkov:
        skip:
          - id: "CKV_AWS_158"
            comment: "Ensure that CloudWatch Log Group is encrypted by KMS"
      cfn_nag:
        rules_to_suppress:
          - id: W84
            reason: "CloudWatch Log Group does not require KMS encryption"
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: "/aws/lambda/generate-subnet-query-string-lambda-logs"
      RetentionInDays: 1

  # Lambda Function Converts Subnet List to String for Substition in PrivateLink Metric Search Expressions
  GenerateSubnetQueryStringFunction:
    Metadata:
      checkov:
        skip:
          - id: "CKV_AWS_117"
            comment: "Ensure that AWS Lambda function is configured inside a VPC"
          - id: "CKV_AWS_116"
            comment: "Ensure that AWS Lambda function is configured for a Dead Letter Queue(DLQ)"
          - id: "CKV_AWS_115"
            comment: "Ensure that AWS Lambda function is configured for function-level concurrent execution limit"
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: "Lambda function does not need to be deployed in a VPC"
          - id: W92
            reason: "Lambda function does not need ReservedConcurrentExecutions"
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.lambda_handler
      Role: !GetAtt  GenerateSubnetQueryStringFunctionRole.Arn
      LoggingConfig:
        LogGroup: !Ref GenerateSubnetQueryStringFunctionLogGroup 
      Runtime: python3.12
      Code:
        ZipFile: |
          import cfnresponse
          import logging
          import json

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def lambda_handler(event, context):
              logger.info(f"Got event\n{json.dumps(event, indent=4, sort_keys=False)}")
              responseData = {}
              subnet_id = event['ResourceProperties']['FirewallSubnetList']

              try:
                  logger.info(f'Incoming RequestType: {event["RequestType"]}')

                  # send success signal on delete
                  if event['RequestType'] == "Delete":
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {})

                  if event['RequestType'] in ["Create", "Update"]:
                      responseData = {}
                      subnet_query_string = f'\\"Subnet Id\\"=\\"{subnet_id}\\"'
                      logger.info(subnet_query_string)
                      responseData['SubnetQueryString'] = subnet_query_string
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData)
              except Exception as err:
                  error_msg = str(err)
                  logger.warning(error_msg)
                  responseData = {"Data": error_msg}
                  cfnresponse.send(event, context, cfnresponse.FAILED, responseData)
                  raise err
              return

  #Custom Resource For Subnet List to String
  GenerateSubnetQueryStringCustomResource:
    Type: AWS::CloudFormation::CustomResource
    Properties:
      ServiceToken: !GetAtt GenerateSubnetQueryStringFunction.Arn
      FirewallSubnetList: !Ref InspectionVPC1FirewallSubnet1

  #Role Allowing Lambda to Publish Log Events to CloudWatch
  GenerateSubnetQueryStringFunctionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
        - Effect: Allow
          Principal:
            Service: lambda.amazonaws.com
          Action: sts:AssumeRole
      Path: /
      Policies:
        - PolicyName: CustomLambdaPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: arn:aws:logs:*:*:*

  ##### Contributor Insights Rules #####

  # Contributor Insights Rule - Top Long-Lived TCP Flows - Age > 350 Seconds
  TopLongLivedTCPFlowsRule:
    Type: AWS::CloudWatch::InsightRule
    Properties:
      RuleBody: !Sub |
        {
            "AggregateOn": "Count",
            "Contribution": {
            "Filters": [{
              "Match": "$.event.netflow.age",
              "GreaterThan": 350
            },
            {
              "Match": "$.event.proto",
              "In": [
                  "TCP"
              ]
            }
            ],
            "Keys": [
              "$.event.src_ip",
              "$.event.src_port",
              "$.event.dest_ip",
              "$.event.dest_port"
            ]
            },
            "LogFormat": "JSON",
            "Schema": {
            "Name": "CloudWatchLogRule",
            "Version": 1
            },
            "LogGroupNames":[
              "${FirewallFlowLogGroupName}"
            ]
        }
      RuleName: !Sub TopLongLivedTCPFlowsRule-${FirewallName}
      RuleState: !Ref ContributorInsightsRuleState

  # Contributor Insights Rule - TCP SYN Without SYN-ACK
  TopTCPSYNWithoutSYNACKRule:
    Type: AWS::CloudWatch::InsightRule
    Properties:
      RuleBody: !Sub |
        {
            "AggregateOn": "Count",
            "Contribution": {
            "Filters": [{
              "Match": "$.event.tcp.tcp_flags",
              "In": [
              "02"
            ]
            }],
            "Keys": [
              "$.event.src_ip",
              "$.event.src_port",
              "$.event.dest_ip",
              "$.event.dest_port"
            ]
            },
            "LogFormat": "JSON",
            "Schema": {
            "Name": "CloudWatchLogRule",
            "Version": 1
            },
            "LogGroupNames":[
              "${FirewallFlowLogGroupName}"
            ]
        }
      RuleName: !Sub TopTCPSYNWithoutSYNACKRule-${FirewallName}
      RuleState: !Ref ContributorInsightsRuleState

  # Contributor Insights Rule - Top Source IP by Packets
  TopSourceIPByPacketsRule:
    Type: AWS::CloudWatch::InsightRule
    Properties:
      RuleBody: !Sub |
        {
          "AggregateOn": "Sum",
          "Contribution": {
            "Filters": [],
            "Keys": [
              "$.event.src_ip"
            ],
            "ValueOf": "$.event.netflow.pkts"
          },
          "LogFormat": "JSON",
          "Schema": {
            "Name": "CloudWatchLogRule",
            "Version": 1
          },
          "LogGroupNames": [
            "${FirewallFlowLogGroupName}"
          ]
        }
      RuleName: !Sub TopSourceIPByPacketsRule-${FirewallName}
      RuleState: !Ref ContributorInsightsRuleState
  
  # Contributor Insights Rule - Top Source IP by Bytes
  TopSourceIPByBytesRule:
    Type: AWS::CloudWatch::InsightRule
    Properties:
      RuleBody: !Sub |
        {
          "AggregateOn": "Sum",
          "Contribution": {
            "Filters": [],
            "Keys": [
              "$.event.src_ip"
            ],
            "ValueOf": "$.event.netflow.bytes"
          },
          "LogFormat": "JSON",
          "Schema": {
            "Name": "CloudWatchLogRule",
            "Version": 1
          },
          "LogGroupNames": [
            "${FirewallFlowLogGroupName}"
          ]
        }
      RuleName: !Sub TopSourceIPByBytesRule-${FirewallName}
      RuleState: !Ref ContributorInsightsRuleState

  # Contributor Insights Rule - Top Destination IP by Packets
  TopDestinationIPByPacketsRule:
    Type: AWS::CloudWatch::InsightRule
    Properties:
      RuleBody: !Sub |
        {
          "AggregateOn": "Sum",
          "Contribution": {
            "Filters": [],
            "Keys": [
              "$.event.dest_ip"
            ],
            "ValueOf": "$.event.netflow.pkts"
          },
          "LogFormat": "JSON",
          "Schema": {
            "Name": "CloudWatchLogRule",
            "Version": 1
          },
          "LogGroupNames": [
            "${FirewallFlowLogGroupName}"
          ]
        }
      RuleName: !Sub TopDestinationIPByPacketsRule-${FirewallName}
      RuleState: !Ref ContributorInsightsRuleState

  # Contributor Insights Rule - Top Destination IP by Bytes
  TopDestinationIPByBytesRule:
    Type: AWS::CloudWatch::InsightRule
    Properties:
      RuleBody: !Sub |
        {
          "AggregateOn": "Sum",
          "Contribution": {
            "Filters": [],
            "Keys": [
              "$.event.dest_ip"
            ],
            "ValueOf": "$.event.netflow.bytes"
          },
          "LogFormat": "JSON",
          "Schema": {
            "Name": "CloudWatchLogRule",
            "Version": 1
          },
          "LogGroupNames": [
            "${FirewallFlowLogGroupName}"
          ]
        }
      RuleName: !Sub TopDestinationIPByBytesRule-${FirewallName}
      RuleState: !Ref ContributorInsightsRuleState

  # Contributor Insights Rule - Top Source and Destination IP by Packets
  TopSourceAndDestinationIPByPacketsRule:
    Type: AWS::CloudWatch::InsightRule
    Properties:
      RuleBody: !Sub |
        {
          "AggregateOn": "Sum",
          "Contribution": {
            "Filters": [],
            "Keys": [
              "$.event.src_ip",
              "$.event.dest_ip"
            ],
            "ValueOf": "$.event.netflow.pkts"
          },
          "LogFormat": "JSON",
          "Schema": {
            "Name": "CloudWatchLogRule",
            "Version": 1
          },
          "LogGroupNames": [
            "${FirewallFlowLogGroupName}"
          ]
        }
      RuleName: !Sub TopSourceAndDestinationIPByPacketsRule-${FirewallName}
      RuleState: !Ref ContributorInsightsRuleState

  # Contributor Insights Rule - Top Source and Destination IP by Bytes
  TopSourceAndDestinationIPByBytesRule:
    Type: AWS::CloudWatch::InsightRule
    Properties:
      RuleBody: !Sub |
        {
            "AggregateOn": "Sum",
            "Contribution": {
              "Filters": [],
              "Keys": [
                "$.event.src_ip",
                "$.event.dest_ip"
              ],
              "ValueOf": "$.event.netflow.bytes"
            },
            "LogFormat": "JSON",
            "Schema": {
            "Name": "CloudWatchLogRule",
            "Version": 1
            },
            "LogGroupNames":[
              "${FirewallFlowLogGroupName}"
            ]
        }
      RuleName: !Sub TopSourceAndDestinationIPByBytesRule-${FirewallName}
      RuleState: !Ref ContributorInsightsRuleState
  
  # Contributor Insights Rule - Top Source Ports
  TopSourcePortsRule:
    Type: AWS::CloudWatch::InsightRule
    Properties:
      RuleBody: !Sub |
        {
          "AggregateOn": "Count",
          "Contribution": {
            "Filters": [],
            "Keys": [
              "$.event.src_port"
            ]
          },
          "LogFormat": "JSON",
          "Schema": {
            "Name": "CloudWatchLogRule",
            "Version": 1
          },
          "LogGroupNames": [
            "${FirewallFlowLogGroupName}"
          ]
        }
      RuleName: !Sub TopSourcePortsRule-${FirewallName}
      RuleState: !Ref ContributorInsightsRuleState 

  # Contributor Insights Rule - Top Destination Ports
  TopDestinationPortsRule:
    Type: AWS::CloudWatch::InsightRule
    Properties:
      RuleBody: !Sub |
        {
          "AggregateOn": "Count",
          "Contribution": {
            "Filters": [],
            "Keys": [
              "$.event.dest_port"
            ]
          },
          "LogFormat": "JSON",
          "Schema": {
            "Name": "CloudWatchLogRule",
            "Version": 1
          },
          "LogGroupNames": [
            "${FirewallFlowLogGroupName}"
          ]
        }
      RuleName: !Sub TopDestinationPortsRule-${FirewallName}
      RuleState: !Ref ContributorInsightsRuleState

  # Contributor Insights Rule - Top TCP Flows
  TopTCPFlowsRule:
    Type: AWS::CloudWatch::InsightRule
    Properties:
      RuleBody: !Sub |
        {
            "AggregateOn": "Count",
            "Contribution": {
            "Filters": [{
              "Match": "$.event.proto",
              "In": [
              "TCP"
            ]
            }],
            "Keys": [
              "$.event.src_ip",
              "$.event.dest_ip",
              "$.event.dest_port"
            ]
            },
            "LogFormat": "JSON",
            "Schema": {
            "Name": "CloudWatchLogRule",
            "Version": 1
            },
            "LogGroupNames":[
              "${FirewallFlowLogGroupName}"
            ]
        }
      RuleName: !Sub TopTCPFlowsRule-${FirewallName}
      RuleState: !Ref ContributorInsightsRuleState
                    
  # Contributor Insights Rule - Top TCP Flows by Packets
  TopTCPFlowsByPacketsRule:
    Type: AWS::CloudWatch::InsightRule
    Properties:
      RuleBody: !Sub |
        {
          "AggregateOn": "Sum",
          "Contribution": {
            "Filters": [
              {
                "Match": "$.event.proto",
                "In": [
                  "TCP"
                ]
              }
            ],
            "Keys": [
              "$.event.src_ip",
              "$.event.dest_ip",
              "$.event.dest_port"
            ],
            "ValueOf": "$.event.netflow.pkts"
          },
          "LogFormat": "JSON",
          "Schema": {
            "Name": "CloudWatchLogRule",
            "Version": 1
          },
          "LogGroupNames": [
            "${FirewallFlowLogGroupName}"
          ]
        }
      RuleName: !Sub TopTCPFlowsByPacketsRule-${FirewallName}
      RuleState: !Ref ContributorInsightsRuleState
  
  # Contributor Insights Rule - Top TCP Flows by Bytes
  TopTCPFlowsByBytesRule:
    Type: AWS::CloudWatch::InsightRule
    Properties:
      RuleBody: !Sub |
        {
          "AggregateOn": "Sum",
          "Contribution": {
            "Filters": [
              {
                "Match": "$.event.proto",
                "In": [
                  "TCP"
                ]
              }
            ],
            "Keys": [
              "$.event.src_ip",
              "$.event.dest_ip",
              "$.event.dest_port"
            ],
            "ValueOf": "$.event.netflow.bytes"
          },
          "LogFormat": "JSON",
          "Schema": {
            "Name": "CloudWatchLogRule",
            "Version": 1
          },
          "LogGroupNames": [
            "${FirewallFlowLogGroupName}"
          ]
        }
      RuleName: !Sub TopTCPFlowsByBytesRule-${FirewallName}
      RuleState: !Ref ContributorInsightsRuleState

  # Contributor Insights Rule - Top UDP Flows
  TopUDPFlowsRule:
    Type: AWS::CloudWatch::InsightRule
    Properties:
      RuleBody: !Sub |
        {
            "AggregateOn": "Count",
            "Contribution": {
            "Filters": [{
              "Match": "$.event.proto",
              "In": [
                "UDP"
            ]
            }],
            "Keys": [
              "$.event.src_ip",
              "$.event.dest_ip",
              "$.event.dest_port"
            ]
            },
            "LogFormat": "JSON",
            "Schema": {
            "Name": "CloudWatchLogRule",
            "Version": 1
            },
            "LogGroupNames":[
              "${FirewallFlowLogGroupName}"
            ]
        }
      RuleName: !Sub TopUDPFlowsRule-${FirewallName}
      RuleState: !Ref ContributorInsightsRuleState

  # Contributor Insights Rule - Top UDP Flows by Packets
  TopUDPFlowsByPacketsRule:
    Type: AWS::CloudWatch::InsightRule
    Properties:
      RuleBody: !Sub |
        {
          "AggregateOn": "Sum",
          "Contribution": {
            "Filters": [
              {
                "Match": "$.event.proto",
                "In": [
                  "UDP"
                ]
              }
            ],
            "Keys": [
              "$.event.src_ip",
              "$.event.dest_ip",
              "$.event.dest_port"
            ],
            "ValueOf": "$.event.netflow.pkts"
          },
          "LogFormat": "JSON",
          "Schema": {
            "Name": "CloudWatchLogRule",
            "Version": 1
          },
          "LogGroupNames": [
            "${FirewallFlowLogGroupName}"
          ]
        }
      RuleName: !Sub TopUDPFlowsByPacketsRule-${FirewallName}
      RuleState: !Ref ContributorInsightsRuleState

  # Contributor Insights Rule - Top UDP Flows by Bytes
  TopUDPFlowsByBytesRule:
    Type: AWS::CloudWatch::InsightRule
    Properties:
      RuleBody: !Sub |
        {
          "AggregateOn": "Sum",
          "Contribution": {
            "Filters": [
              {
                "Match": "$.event.proto",
                "In": [
                  "UDP"
                ]
              }
            ],
            "Keys": [
              "$.event.src_ip",
              "$.event.dest_ip",
              "$.event.dest_port"
            ],
            "ValueOf": "$.event.netflow.bytes"
          },
          "LogFormat": "JSON",
          "Schema": {
            "Name": "CloudWatchLogRule",
            "Version": 1
          },
          "LogGroupNames": [
            "${FirewallFlowLogGroupName}"
          ]
        }
      RuleName: !Sub TopUDPFlowsByBytesRule-${FirewallName}
      RuleState: !Ref ContributorInsightsRuleState

  # Contributor Insights Rule - Top ICMP Flows
  TopICMPFlowsRule:
    Type: AWS::CloudWatch::InsightRule
    Properties:
      RuleBody: !Sub |
        {
            "AggregateOn": "Count",
            "Contribution": {
            "Filters": [{
              "Match": "$.event.proto",
              "In": [
              "ICMP"
            ]
            }],
            "Keys": [
              "$.event.src_ip",
              "$.event.dest_ip"
            ]
            },
            "LogFormat": "JSON",
            "Schema": {
            "Name": "CloudWatchLogRule",
            "Version": 1
            },
            "LogGroupNames":[
              "${FirewallFlowLogGroupName}"
            ]
        }
      RuleName: !Sub TopICMPFlowsRule-${FirewallName}
      RuleState: !Ref ContributorInsightsRuleState

  # Contributor Insights Rule - Top Blocked Remote Access Ports
  TopBlockedRemoteAccessPortsRule:
    Type: AWS::CloudWatch::InsightRule
    Properties:
      RuleBody: !Sub |
        {
          "AggregateOn": "Count",
          "Contribution": {
            "Filters": [
              {
                "Match": "$.event.alert.action",
                "In": [
                  "blocked"
                ]
              },
              {
                "Match": "$.event.dest_port",
                "In": [
                  "22",
                  "23",
                  "3389"
                ]
              }
            ],
            "Keys": [
              "$.event.src_ip",
              "$.event.dest_ip",
              "$.event.dest_port"
            ]
          },
          "LogFormat": "JSON",
          "Schema": {
            "Name": "CloudWatchLogRule",
            "Version": 1
          },
          "LogGroupNames": [
            "${FirewallAlertLogGroupName}"
          ]
        }
      RuleName: !Sub TopBlockedRemoteAccessPortsRule-${FirewallName}
      RuleState: !Ref ContributorInsightsRuleState   

  # Contributor Insights Rule - Top Blocked TCP Flows
  TopBlockedTCPFlowsRule:
    Type: AWS::CloudWatch::InsightRule
    Properties:
      RuleBody: !Sub |
        {
          "AggregateOn": "Count",
          "Contribution": {
            "Filters": [
              {
                "Match": "$.event.alert.action",
                "In": [
                  "blocked"
                ]
              },
              {
                "Match": "$.event.proto",
                "In": [
                  "TCP"
                ]
              }
            ],
            "Keys": [
              "$.event.src_ip",
              "$.event.dest_ip",
              "$.event.dest_port"
            ]
          },
          "LogFormat": "JSON",
          "Schema": {
            "Name": "CloudWatchLogRule",
            "Version": 1
          },
          "LogGroupNames": [
            "${FirewallAlertLogGroupName}"
          ]
        }
      RuleName: !Sub TopBlockedTCPFlowsRule-${FirewallName}
      RuleState: !Ref ContributorInsightsRuleState 

  # Contributor Insights Rule - Top Blocked UDP Flows
  TopBlockedUDPFlowsRule:
    Type: AWS::CloudWatch::InsightRule
    Properties:
      RuleBody: !Sub |
        {
          "AggregateOn": "Count",
          "Contribution": {
            "Filters": [
              {
                "Match": "$.event.alert.action",
                "In": [
                  "blocked"
                ]
              },
              {
                "Match": "$.event.proto",
                "In": [
                  "UDP"
                ]
              }
            ],
            "Keys": [
              "$.event.src_ip",
              "$.event.dest_ip",
              "$.event.dest_port"
            ]
          },
          "LogFormat": "JSON",
          "Schema": {
            "Name": "CloudWatchLogRule",
            "Version": 1
          },
          "LogGroupNames": [
            "${FirewallAlertLogGroupName}"
          ]
        }
      RuleName: !Sub TopBlockedUDPFlowsRule-${FirewallName}
      RuleState: !Ref ContributorInsightsRuleState

  # Contributor Insights Rule - Top HTTP Host Header
  TopHTTPHostHeaderRule:
    Type: AWS::CloudWatch::InsightRule
    Properties:
      RuleBody: !Sub |
        {
            "AggregateOn": "Count",
            "Contribution": {
            "Filters": [{
              "Match": "$.event.alert.action",
              "NotIn": [
              "blocked"
            ]
            }],
            "Keys": [
              "$.event.http.hostname"
            ]
            },
            "LogFormat": "JSON",
            "Schema": {
            "Name": "CloudWatchLogRule",
            "Version": 1
            },
            "LogGroupNames":[
              "${FirewallAlertLogGroupName}"
            ]
        }
      RuleName: !Sub TopHTTPHostHeaderRule-${FirewallName}
      RuleState: !Ref ContributorInsightsRuleState 

  # Contributor Insights Rule - Top Blocked HTTP Host Header
  TopBlockedHTTPHostHeaderRule:
    Type: AWS::CloudWatch::InsightRule
    Properties:
      RuleBody: !Sub |
        {
            "AggregateOn": "Count",
            "Contribution": {
            "Filters": [{
              "Match": "$.event.alert.action",
              "In": [
              "blocked"
            ]
            }],
            "Keys": [
              "$.event.http.hostname"
            ]
            },
            "LogFormat": "JSON",
            "Schema": {
            "Name": "CloudWatchLogRule",
            "Version": 1
            },
            "LogGroupNames":[
              "${FirewallAlertLogGroupName}"
            ]
        }
      RuleName: !Sub TopBlockedHTTPHostHeaderRule-${FirewallName}
      RuleState: !Ref ContributorInsightsRuleState

  # Contributor Insights Rule - Top HTTP URI Paths
  TopHTTPURIPathsRule:
    Type: AWS::CloudWatch::InsightRule
    Properties:
      RuleBody: !Sub |
        {
          "AggregateOn": "Count",
          "Contribution": {
            "Filters": [],
            "Keys": [
              "$.event.http.url"
            ]
          },
          "LogFormat": "JSON",
          "Schema": {
            "Name": "CloudWatchLogRule",
            "Version": 1
          },
          "LogGroupNames": [
            "${FirewallAlertLogGroupName}"
          ]
        }
      RuleName: !Sub TopHTTPURIPathsRule-${FirewallName}
      RuleState: !Ref ContributorInsightsRuleState

  # Contributor Insights Rule - Top HTTP User-Agents
  TopHTTPUserAgentsRule:
    Type: AWS::CloudWatch::InsightRule
    Properties:
      RuleBody: !Sub |
        {
          "AggregateOn": "Count",
          "Contribution": {
            "Filters": [],
            "Keys": [
              "$.event.http.http_user_agent"
            ]
          },
          "LogFormat": "JSON",
          "Schema": {
            "Name": "CloudWatchLogRule",
            "Version": 1
          },
          "LogGroupNames": [
            "${FirewallAlertLogGroupName}"
          ]
        }
      RuleName: !Sub TopHTTPUserAgentsRule-${FirewallName}
      RuleState: !Ref ContributorInsightsRuleState

  # Contributor Insights Rule - Top TLS SNI
  TopTLSSNIRule:
    Type: AWS::CloudWatch::InsightRule
    Properties:
      RuleBody: !Sub |
        {
            "AggregateOn": "Count",
            "Contribution": {
            "Filters": [{
              "Match": "$.event.alert.action",
              "NotIn": [
              "blocked"
            ]
            }],
            "Keys": [
              "$.event.tls.sni"
            ]
            },
            "LogFormat": "JSON",
            "Schema": {
            "Name": "CloudWatchLogRule",
            "Version": 1
            },
            "LogGroupNames":[
              "${FirewallAlertLogGroupName}"
            ]
        }
      RuleName: !Sub TopTLSSNIRule-${FirewallName}
      RuleState: !Ref ContributorInsightsRuleState   

  # Contributor Insights Rule - Top Blocked TLS SNI
  TopBlockedTLSSNIRule:
    Type: AWS::CloudWatch::InsightRule
    Properties:
      RuleBody: !Sub |
        {
            "AggregateOn": "Count",
            "Contribution": {
            "Filters": [{
              "Match": "$.event.alert.action",
              "In": [
              "blocked"
            ]
            }],
            "Keys": [
              "$.event.tls.sni"
            ]
            },
            "LogFormat": "JSON",
            "Schema": {
            "Name": "CloudWatchLogRule",
            "Version": 1
            },
            "LogGroupNames":[
              "${FirewallAlertLogGroupName}"
            ]
        }
      RuleName: !Sub TopBlockedTLSSNIRule-${FirewallName}
      RuleState: !Ref ContributorInsightsRuleState

    
  ##### CloudWatch Dashboard #####

  # CloudWatch Dashboard Body with Metrics, Contribtor Insights rules, and Logs Insights Queries
  FirewallDashboard:
    Type: AWS::CloudWatch::Dashboard
    DependsOn:
      - InspectionVPC1Anfw1
    Properties:
      DashboardBody: !Sub
        - |
          {
              "widgets": [
                  {
                      "height": 2,
                      "width": 24,
                      "y": 0,
                      "x": 0,
                      "type": "text",
                      "properties": {
                          "markdown": "# Overview\n[button:primary:Firewall Console](https://${AWS::Region}.console.aws.amazon.com/vpc/home?region=${AWS::Region}#NetworkFirewallDetails:arn=arn_aws_network-firewall_${AWS::Region}_${AWS::AccountId}_firewall~${FirewallName}) [button:Troubleshooting](https://docs.aws.amazon.com/network-firewall/latest/developerguide/troubleshooting.html) [button:re&#58;Post](https://repost.aws/search/content?globalSearch=network%20firewall)",
                          "background": "transparent"
                      }
                  },
                  {
                      "height": 1,
                      "width": 24,
                      "y": 2,
                      "x": 0,
                      "type": "text",
                      "properties": {
                          "markdown": "# Firewall Endpoints",
                          "background": "transparent"
                      }
                  },        
                  {
                      "height": 7,
                      "width": 6,
                      "y": 3,
                      "x": 0,
                      "type": "metric",
                      "properties": {
                          "metrics": [
                              [ { "expression": "SEARCH(' Namespace=\"AWS/PrivateLinkEndpoints\" ${subnet_query_string}', 'Sum', 300)", "label": "${!PROP('Dim.VPC Endpoint Id')}  ${!PROP('MetricName')}", "id": "e1", "region": "${AWS::Region}" } ]
                          ],
                          "view": "timeSeries",
                          "stacked": false,
                          "region": "${AWS::Region}",
                          "stat": "Sum",
                          "period": 300,
                          "title": "Firewall Endpoint ENI (GWLBe/VPCe) Metrics",
                          "legend": {
                              "position": "bottom"
                          }
                      }
                  },
                  {
                      "height": 7,
                      "width": 6,
                      "y": 3,
                      "x": 6,
                      "type": "metric",
                      "properties": {
                          "metrics": [
                              [ { "expression": "((m1/300)/.008)", "label": "${!PROP('Dim.VPC Endpoint Id')}", "id": "e1", "period": 300, "stat": "Sum", "region": "${AWS::Region}" } ],
                              [ { "expression": "SEARCH('Namespace=\"AWS/PrivateLinkEndpoints\" ${subnet_query_string} MetricName=\"BytesProcessed\"', 'Sum', 300)", "label": "Expression1", "id": "m1", "region": "${AWS::Region}", "visible": false } ]
                          ],
                          "view": "gauge",
                          "stacked": true,
                          "region": "${AWS::Region}",
                          "stat": "Sum",
                          "period": 60,
                          "title": "Per Endpoint Utilization Gbps",
                          "yAxis": {
                              "left": {
                                  "min": 0,
                                  "max": 100000000000
                              }
                          },
                          "setPeriodToTimeRange": false,
                          "sparkline": true,
                          "trend": true
                      }
                  },
                  {
                      "height": 7,
                      "width": 6,
                      "y": 3,
                      "x": 12,
                      "type": "metric",
                      "properties": {
                          "metrics": [
                              [ { "expression": "SEARCH('Namespace=\"AWS/PrivateLinkEndpoints\" ${subnet_query_string} MetricName=\"ActiveConnections\"', 'Sum', 300)", "label": "${!PROP('Dim.VPC Endpoint Id')}  ${!PROP('MetricName')}", "id": "m1", "region": "${AWS::Region}", "visible": true } ]
                          ],
                          "sparkline": true,
                          "view": "singleValue",
                          "region": "${AWS::Region}",
                          "period": 300,
                          "stat": "Sum",
                          "title": "ActiveConnections"
                      }
                  },
                  {
                      "height": 7,
                      "width": 6,
                      "y": 3,
                      "x": 18,
                      "type": "metric",
                      "properties": {
                          "metrics": [
                              [ { "expression": "SEARCH('Namespace=\"AWS/PrivateLinkEndpoints\" ${subnet_query_string} MetricName=\"BytesProcessed\"', 'Sum', 300)", "label": "${!PROP('Dim.VPC Endpoint Id')}  ${!PROP('MetricName')}", "id": "m2", "region": "${AWS::Region}", "visible": true } ]
                          ],
                          "sparkline": true,
                          "view": "singleValue",
                          "region": "${AWS::Region}",
                          "period": 300,
                          "stat": "Sum",
                          "title": "BytesProcessed"
                      }
                  },
                  {
                      "height": 1,
                      "width": 24,
                      "y": 10,
                      "x": 0,
                      "type": "text",
                      "properties": {
                          "markdown": "# Firewall Engines",
                          "background": "transparent"
                      }
                  },
                  {
                      "height": 1,
                      "width": 24,
                      "y": 11,
                      "x": 0,
                      "type": "text",
                      "properties": {
                          "markdown": "## Stateless",
                          "background": "transparent"
                      }
                  },        
                  {
                      "height": 7,
                      "width": 6,
                      "y": 12,
                      "x": 0,
                      "type": "metric",
                      "properties": {
                          "metrics": [
                              [ { "expression": "SEARCH('Namespace=\"AWS/NetworkFirewall\" FirewallName=\"${FirewallName}\" Engine=\"Stateless\"', 'Sum')", "label": "", "id": "e1", "region": "${AWS::Region}" } ]
                          ],
                          "view": "timeSeries",
                          "stacked": false,
                          "region": "${AWS::Region}",
                          "stat": "Sum",
                          "period": 300,
                          "title": "Stateless Engine Metrics",
                          "legend": {
                              "position": "bottom"
                          }
                      }
                  },
                  {
                      "height": 7,
                      "width": 6,
                      "y": 12,
                      "x": 6,
                      "type": "metric",
                      "properties": {
                          "metrics": [
                              [ { "expression": "SEARCH('Namespace=\"AWS/NetworkFirewall\" FirewallName=\"${FirewallName}\" Engine=\"Stateless\" MetricName=\"PassedPackets\"', 'Sum', 300)", "label": "${!PROP('Dim.AvailabilityZone')} ${!PROP('MetricName')}", "id": "e1", "region": "${AWS::Region}" } ]
                          ],
                          "sparkline": true,
                          "view": "singleValue",
                          "region": "${AWS::Region}",
                          "title": "Stateless Passed Packets",
                          "period": 300,
                          "stat": "Sum"
                      }
                  },
                  {
                      "height": 7,
                      "width": 6,
                      "y": 12,
                      "x": 12,
                      "type": "metric",
                      "properties": {
                          "metrics": [
                              [ { "expression": "SEARCH('Namespace=\"AWS/NetworkFirewall\" FirewallName=\"${FirewallName}\" Engine=\"Stateless\" MetricName=\"DroppedPackets\"', 'Sum', 300)", "label": "${!PROP('Dim.AvailabilityZone')} ${!PROP('MetricName')}", "id": "e1", "region": "${AWS::Region}" } ]
                          ],
                          "sparkline": true,
                          "view": "singleValue",
                          "region": "${AWS::Region}",
                          "title": "Stateless Dropped Packets - Rule Action",
                          "period": 300,
                          "stat": "Sum"
                      }
                  },
                  {
                      "height": 7,
                      "width": 6,
                      "y": 12,
                      "x": 18,
                      "type": "metric",
                      "properties": {
                          "metrics": [
                              [ { "expression": "SEARCH('Namespace=\"AWS/NetworkFirewall\" FirewallName=\"${FirewallName}\" Engine=\"Stateless\" MetricName=Other OR Invalid', 'Sum', 300)", "label": "${!PROP('Dim.AvailabilityZone')} ${!PROP('MetricName')}", "id": "e1", "region": "${AWS::Region}" } ]
                          ],
                          "sparkline": true,
                          "view": "singleValue",
                          "region": "${AWS::Region}",
                          "title": "Stateless Dropped Packets - Other",
                          "period": 300,
                          "stat": "Sum"
                      }
                  },
                  {
                      "height": 1,
                      "width": 24,
                      "y": 19,
                      "x": 0,
                      "type": "text",
                      "properties": {
                          "markdown": "## Stateful\n",
                          "background": "transparent"
                      }
                  },
                  {
                      "height": 7,
                      "width": 6,
                      "y": 20,
                      "x": 0,
                      "type": "metric",
                      "properties": {
                          "metrics": [
                              [ { "expression": "SEARCH('Namespace=\"AWS/NetworkFirewall\" FirewallName=\"${FirewallName}\" Engine=\"Stateful\"', 'Sum')", "label": "", "id": "e1", "region": "${AWS::Region}" } ]
                          ],
                          "view": "timeSeries",
                          "stacked": false,
                          "region": "${AWS::Region}",
                          "stat": "Sum",
                          "period": 300,
                          "title": "Stateful Engine Metrics"
                      }
                  },
                  {
                      "height": 7,
                      "width": 6,
                      "y": 20,
                      "x": 6,
                      "type": "metric",
                      "properties": {
                          "metrics": [
                              [ { "expression": "SEARCH('Namespace=\"AWS/NetworkFirewall\" FirewallName=\"${FirewallName}\" Engine=\"Stateful\" MetricName=\"PassedPackets\"', 'Sum', 300)", "label": "${!PROP('Dim.AvailabilityZone')} ${!PROP('MetricName')}", "id": "e1", "region": "${AWS::Region}" } ]
                          ],
                          "sparkline": true,
                          "view": "singleValue",
                          "region": "${AWS::Region}",
                          "period": 300,
                          "stat": "Sum",
                          "title": "Stateful Passed Packets"
                      }
                  },
                  {
                      "height": 7,
                      "width": 6,
                      "y": 20,
                      "x": 12,
                      "type": "metric",
                      "properties": {
                          "metrics": [
                              [ { "expression": "SEARCH('Namespace=\"AWS/NetworkFirewall\" FirewallName=\"${FirewallName}\" Engine=\"Stateful\" MetricName=\"DroppedPackets\"', 'Sum', 300)", "label": "${!PROP('Dim.AvailabilityZone')} ${!PROP('MetricName')}", "id": "e1", "region": "${AWS::Region}" } ]
                          ],
                          "sparkline": true,
                          "view": "singleValue",
                          "region": "${AWS::Region}",
                          "period": 300,
                          "stat": "Sum",
                          "title": "Stateful Dropped Packets"
                      }
                  },
                  {
                      "height": 7,
                      "width": 6,
                      "y": 20,
                      "x": 18,
                      "type": "metric",
                      "properties": {
                          "metrics": [
                              [ { "expression": "SEARCH('Namespace=\"AWS/NetworkFirewall\" FirewallName=\"${FirewallName}\" Engine=\"Stateful\" MetricName=\"RejectedPackets\"', 'Sum', 300)", "label": "${!PROP('Dim.AvailabilityZone')} ${!PROP('MetricName')}", "id": "e1", "region": "${AWS::Region}" } ]
                          ],
                          "sparkline": true,
                          "view": "singleValue",
                          "region": "${AWS::Region}",
                          "period": 300,
                          "stat": "Sum",
                          "title": "Stateful Rejected Packets"
                      }
                  },
                  {
                      "height": 7,
                      "width": 6,
                      "y": 27,
                      "x": 0,
                      "type": "metric",
                      "properties": {
                          "metrics": [
                              [ { "expression": "SEARCH('Namespace=\"AWS/NetworkFirewall\" FirewallName=\"${FirewallName}\" MetricName=TLS', 'Sum', 300)", "label": "${!PROP('Dim.AvailabilityZone')} ${!PROP('MetricName')}", "id": "e1", "region": "${AWS::Region}" } ]
                          ],
                          "view": "timeSeries",
                          "stacked": false,
                          "region": "${AWS::Region}",
                          "stat": "Sum",
                          "period": 300,
                          "title": "TLS Inspection"
                      }
                  },
                  {
                      "height": 7,
                      "width": 6,
                      "y": 27,
                      "x": 6,
                      "type": "metric",
                      "properties": {
                          "metrics": [
                              [ { "expression": "SEARCH('Namespace=\"AWS/NetworkFirewall\" FirewallName=\"${FirewallName}\" MetricName=\"StreamExceptionPolicyPackets\"', 'Sum', 300)", "label": "${!PROP('Dim.AvailabilityZone')} ${!PROP('MetricName')}", "id": "e1", "region": "${AWS::Region}" } ]
                          ],
                          "view": "timeSeries",
                          "stacked": false,
                          "region": "${AWS::Region}",
                          "stat": "Sum",
                          "period": 300,
                          "title": "Stream Exception Policy Packets"
                      }
                  },
                  {
                      "height": 7,
                      "width": 6,
                      "y": 27,
                      "x": 12,
                      "type": "metric",
                      "properties": {
                          "period": 60,
                          "insightRule": {
                              "maxContributorCount": 10,
                              "orderBy": "Sum",
                              "ruleName": "${TopLongLivedTCPFlowsRule.RuleName}"
                          },
                          "stacked": false,
                          "view": "timeSeries",
                          "yAxis": {
                              "left": {
                                  "showUnits": false
                              },
                              "right": {
                                  "showUnits": false
                              }
                          },
                          "region": "${AWS::Region}",
                          "title": "Top Long-Lived TCP Flows - Age > 350s",
                          "legend": {
                              "position": "right"
                          }
                      }
                  },
                  {
                      "height": 7,
                      "width": 6,
                      "y": 27,
                      "x": 18,
                      "type": "metric",
                      "properties": {
                          "period": 60,
                          "insightRule": {
                              "maxContributorCount": 10,
                              "orderBy": "Sum",
                              "ruleName": "${TopTCPSYNWithoutSYNACKRule.RuleName}"
                          },
                          "stacked": false,
                          "view": "timeSeries",
                          "yAxis": {
                              "left": {
                                  "showUnits": false
                              },
                              "right": {
                                  "showUnits": false
                              }
                          },
                          "region": "${AWS::Region}",
                          "title": "Top TCP Flows - SYN Without SYN-ACK",
                          "legend": {
                              "position": "right"
                          }
                      }
                  },
                  {
                      "height": 1,
                      "width": 24,
                      "y": 34,
                      "x": 0,
                      "type": "text",
                      "properties": {
                          "markdown": "# Top Talkers\n",
                          "background": "transparent"
                      }
                  },
                  {
                      "height": 7,
                      "width": 6,
                      "y": 35,
                      "x": 0,
                      "type": "metric",
                      "properties": {
                          "period": 60,
                          "region": "${AWS::Region}",
                          "stacked": false,
                          "timezone": "local",
                          "title": "Top Source IP by Packets",
                          "view": "timeSeries",
                          "legend": {
                              "position": "right"
                          },
                          "insightRule": {
                              "maxContributorCount": 10,
                              "orderBy": "Sum",
                              "ruleName": "${TopSourceIPByPacketsRule.RuleName}"
                          }
                      }
                  },
                  {
                      "height": 7,
                      "width": 6,
                      "y": 35,
                      "x": 6,
                      "type": "metric",
                      "properties": {
                          "period": 60,
                          "region": "${AWS::Region}",
                          "stacked": false,
                          "timezone": "local",
                          "title": "Top Source IP by Bytes",
                          "view": "timeSeries",
                          "legend": {
                              "position": "right"
                          },
                          "insightRule": {
                              "maxContributorCount": 10,
                              "orderBy": "Sum",
                              "ruleName": "${TopSourceIPByBytesRule.RuleName}"
                          }
                      }
                  },
                  {
                      "height": 7,
                      "width": 6,
                      "y": 35,
                      "x": 12,
                      "type": "metric",
                      "properties": {
                          "period": 60,
                          "region": "${AWS::Region}",
                          "stacked": false,
                          "timezone": "local",
                          "title": "Top Destination IP by Packets",
                          "view": "timeSeries",
                          "legend": {
                              "position": "right"
                          },
                          "insightRule": {
                              "maxContributorCount": 10,
                              "orderBy": "Sum",
                              "ruleName": "${TopDestinationIPByPacketsRule.RuleName}"
                          }
                      }
                  },
                  {
                      "height": 7,
                      "width": 6,
                      "y": 35,
                      "x": 18,
                      "type": "metric",
                      "properties": {
                          "period": 60,
                          "region": "${AWS::Region}",
                          "stacked": false,
                          "timezone": "local",
                          "title": "Top Destination IP by Bytes",
                          "view": "timeSeries",
                          "legend": {
                              "position": "right"
                          },
                          "insightRule": {
                              "maxContributorCount": 10,
                              "orderBy": "Sum",
                              "ruleName": "${TopDestinationIPByBytesRule.RuleName}"
                          }
                      }
                  },
                  {
                      "height": 7,
                      "width": 12,
                      "y": 42,
                      "x": 0,
                      "type": "metric",
                      "properties": {
                          "period": 60,
                          "region": "${AWS::Region}",
                          "stacked": false,
                          "timezone": "local",
                          "title": "Top Source and Destination IP by Packets",
                          "view": "timeSeries",
                          "legend": {
                              "position": "right"
                          },
                          "insightRule": {
                              "maxContributorCount": 10,
                              "orderBy": "Sum",
                              "ruleName": "${TopSourceAndDestinationIPByPacketsRule.RuleName}"
                          }
                      }
                  },
                  {
                      "height": 7,
                      "width": 12,
                      "y": 42,
                      "x": 12,
                      "type": "metric",
                      "properties": {
                          "period": 60,
                          "insightRule": {
                              "maxContributorCount": 10,
                              "orderBy": "Sum",
                              "ruleName": "${TopSourceAndDestinationIPByBytesRule.RuleName}"
                          },
                          "stacked": false,
                          "view": "timeSeries",
                          "yAxis": {
                              "left": {
                                  "showUnits": false
                              },
                              "right": {
                                  "showUnits": false
                              }
                          },
                          "region": "${AWS::Region}",
                          "title": "Top Source and Destination IP by Bytes",
                          "legend": {
                              "position": "right"
                          }
                      }
                  },
                  {
                      "height": 1,
                      "width": 24,
                      "y": 49,
                      "x": 0,
                      "type": "text",
                      "properties": {
                          "markdown": "# Top Protocols",
                          "background": "transparent"
                      }
                  },
                  {
                      "height": 7,
                      "width": 6,
                      "y": 50,
                      "x": 0,
                      "type": "log",
                      "properties": {
                          "query": "SOURCE '${FirewallFlowLogGroupName}' | stats count() as proto by event.proto\n| sort proto desc\n| limit 10",
                          "region": "${AWS::Region}",
                          "stacked": false,
                          "title": "Top Protocols",
                          "view": "pie"
                      }
                  },
                  {
                      "height": 7,
                      "width": 6,
                      "y": 50,
                      "x": 6,
                      "type": "log",
                      "properties": {
                          "query": "SOURCE '${FirewallFlowLogGroupName}' | stats count() as app_proto by event.app_proto\n| sort app_proto desc\n| limit 10",
                          "region": "${AWS::Region}",
                          "stacked": false,
                          "view": "pie",
                          "title": "Top Application Layer Protocols Detected"
                      }
                  },
                  {
                      "height": 7,
                      "width": 6,
                      "y": 50,
                      "x": 12,
                      "type": "metric",
                      "properties": {
                          "period": 60,
                          "region": "${AWS::Region}",
                          "stacked": false,
                          "timezone": "local",
                          "title": "Top Source Port",
                          "view": "timeSeries",
                          "legend": {
                              "position": "right"
                          },
                          "insightRule": {
                              "maxContributorCount": 10,
                              "orderBy": "Sum",
                              "ruleName": "${TopSourcePortsRule.RuleName}"
                          }
                      }
                  },
                  {
                      "height": 7,
                      "width": 6,
                      "y": 50,
                      "x": 18,
                      "type": "metric",
                      "properties": {
                          "period": 60,
                          "region": "${AWS::Region}",
                          "stacked": false,
                          "timezone": "local",
                          "title": "Top Destination Port",
                          "view": "timeSeries",
                          "legend": {
                              "position": "right"
                          },
                          "insightRule": {
                              "maxContributorCount": 10,
                              "orderBy": "Sum",
                              "ruleName": "${TopDestinationPortsRule.RuleName}"
                          }
                      }
                  },
                  {
                      "height": 7,
                      "width": 6,
                      "y": 57,
                      "x": 0,
                      "type": "metric",
                      "properties": {
                          "period": 60,
                          "insightRule": {
                              "maxContributorCount": 10,
                              "orderBy": "Sum",
                              "ruleName": "${TopTCPFlowsRule.RuleName}"
                          },
                          "stacked": false,
                          "view": "timeSeries",
                          "yAxis": {
                              "left": {
                                  "showUnits": false
                              },
                              "right": {
                                  "showUnits": false
                              }
                          },
                          "region": "${AWS::Region}",
                          "title": "Top TCP Flows",
                          "legend": {
                              "position": "right"
                          }
                      }
                  },
                  {
                      "height": 7,
                      "width": 6,
                      "y": 57,
                      "x": 6,
                      "type": "metric",
                      "properties": {
                          "period": 60,
                          "insightRule": {
                              "maxContributorCount": 10,
                              "orderBy": "Sum",
                              "ruleName": "${TopTCPFlowsByPacketsRule.RuleName}"
                          },
                          "stacked": false,
                          "view": "timeSeries",
                          "yAxis": {
                              "left": {
                                  "showUnits": false
                              },
                              "right": {
                                  "showUnits": false
                              }
                          },
                          "region": "${AWS::Region}",
                          "title": "Top TCP Flows by Packets",
                          "legend": {
                              "position": "right"
                          }
                      }
                  },
                  {
                      "height": 7,
                      "width": 6,
                      "y": 57,
                      "x": 12,
                      "type": "metric",
                      "properties": {
                          "period": 60,
                          "insightRule": {
                              "maxContributorCount": 10,
                              "orderBy": "Sum",
                              "ruleName": "${TopTCPFlowsByBytesRule.RuleName}"
                          },
                          "stacked": false,
                          "view": "timeSeries",
                          "yAxis": {
                              "left": {
                                  "showUnits": false
                              },
                              "right": {
                                  "showUnits": false
                              }
                          },
                          "region": "${AWS::Region}",
                          "title": "Top TCP Flows by Bytes",
                          "legend": {
                              "position": "right"
                          }
                      }
                  },
                  {
                      "height": 7,
                      "width": 6,
                      "y": 57,
                      "x": 18,
                      "type": "log",
                      "properties": {
                          "query": "SOURCE '${FirewallFlowLogGroupName}' | stats count() as tcp_flags by event.tcp.tcp_flags\n| sort tcp_flags desc\n| limit 10",
                          "region": "${AWS::Region}",
                          "title": "Top TCP Flags",
                          "view": "pie"
                      }
                  },
                  {
                      "height": 7,
                      "width": 6,
                      "y": 64,
                      "x": 0,
                      "type": "metric",
                      "properties": {
                          "period": 60,
                          "region": "${AWS::Region}",
                          "stacked": false,
                          "timezone": "local",
                          "title": "Top UDP Flows",
                          "view": "timeSeries",
                          "legend": {
                              "position": "right"
                          },
                          "insightRule": {
                              "maxContributorCount": 10,
                              "orderBy": "Sum",
                              "ruleName": "${TopUDPFlowsRule.RuleName}"
                          }
                      }
                  },
                  {
                      "height": 7,
                      "width": 6,
                      "y": 64,
                      "x": 6,
                      "type": "metric",
                      "properties": {
                          "period": 60,
                          "region": "${AWS::Region}",
                          "stacked": false,
                          "timezone": "local",
                          "title": "Top UDP Flows by Packets",
                          "view": "timeSeries",
                          "legend": {
                              "position": "right"
                          },
                          "insightRule": {
                              "maxContributorCount": 10,
                              "orderBy": "Sum",
                              "ruleName": "${TopUDPFlowsByPacketsRule.RuleName}"
                          }
                      }
                  },
                  {
                      "height": 7,
                      "width": 6,
                      "y": 64,
                      "x": 12,
                      "type": "metric",
                      "properties": {
                          "period": 60,
                          "region": "${AWS::Region}",
                          "stacked": false,
                          "timezone": "local",
                          "title": "Top UDP Flows by Bytes",
                          "view": "timeSeries",
                          "legend": {
                              "position": "right"
                          },
                          "insightRule": {
                              "maxContributorCount": 10,
                              "orderBy": "Sum",
                              "ruleName": "${TopUDPFlowsByBytesRule.RuleName}"
                          }
                      }
                  },
                  {
                      "height": 7,
                      "width": 6,
                      "y": 64,
                      "x": 18,
                      "type": "metric",
                      "properties": {
                          "period": 60,
                          "region": "${AWS::Region}",
                          "stacked": false,
                          "timezone": "local",
                          "title": "Top ICMP Flows",
                          "view": "timeSeries",
                          "legend": {
                              "position": "right"
                          },
                          "insightRule": {
                              "maxContributorCount": 10,
                              "orderBy": "Sum",
                              "ruleName": "${TopICMPFlowsRule.RuleName}"
                          }
                      }
                  },
                  {
                      "height": 1,
                      "width": 24,
                      "y": 71,
                      "x": 0,
                      "type": "text",
                      "properties": {
                          "markdown": "# Alert Log Analysis",
                          "background": "transparent"
                      }
                  },
                  {
                      "height": 1,
                      "width": 24,
                      "y": 72,
                      "x": 0,
                      "type": "text",
                      "properties": {
                          "markdown": "## Rule Summary",
                          "background": "transparent"
                      }
                  },
                  {
                      "height": 7,
                      "width": 6,
                      "y": 73,
                      "x": 0,
                      "type": "log",
                      "properties": {
                          "query": "SOURCE '${FirewallAlertLogGroupName}' | stats count (*) as Count by event.alert.signature_id as SID, event.alert.action as Action, event.alert.signature as Message, event.proto as Proto\n| display SID, Action, Message, Proto, Count\n| filter event.alert.action = 'blocked'\n| sort Count desc\n| limit 10",
                          "region": "${AWS::Region}",
                          "stacked": false,
                          "title": "Top Drop/Reject Rules",
                          "view": "table"
                      }
                  },
                  {
                      "height": 7,
                      "width": 6,
                      "y": 73,
                      "x": 6,
                      "type": "log",
                      "properties": {
                          "query": "SOURCE '${FirewallAlertLogGroupName}' | stats count (*) as Count by event.alert.signature_id as SID, event.alert.action as Action, event.alert.signature as Message, event.proto as Proto\n| display SID, Action, Message, Proto, Count\n| filter event.alert.action != 'blocked'\n| sort Count desc\n| limit 10",
                          "region": "${AWS::Region}",
                          "stacked": false,
                          "title": "Top Alert Rules",
                          "view": "table"
                      }
                  },
                  {
                      "height": 7,
                      "width": 12,
                      "y": 73,
                      "x": 12,
                      "type": "log",
                      "properties": {
                          "query": "SOURCE '${FirewallAlertLogGroupName}' | fields event.timestamp as Time, event.alert.signature_id as SID, event.alert.signature as Message, event.proto as Proto, event.src_ip as Src_IP, event.src_port as Src_Port, event.dest_ip as Dest_IP, event.dest_port as Dest_Port\n| sort event.timestamp desc\n| limit 10",
                          "region": "${AWS::Region}",
                          "stacked": false,
                          "title": "Recent Alert Log Events",
                          "view": "table"
                      }
                  },
                  {
                      "height": 7,
                      "width": 6,
                      "y": 80,
                      "x": 0,
                      "type": "log",
                      "properties": {
                          "query": "SOURCE '${FirewallAlertLogGroupName}' | stats count() as blocked_src_ip by event.src_ip as src_ip\n| filter event.alert.action = 'blocked'\n| sort blocked_src_ip desc\n| limit 10",
                          "region": "${AWS::Region}",
                          "title": "Top Blocked Source IPs",
                          "view": "pie"
                      }
                  },
                  {
                      "height": 7,
                      "width": 6,
                      "y": 80,
                      "x": 6,
                      "type": "log",
                      "properties": {
                          "query": "SOURCE '${FirewallAlertLogGroupName}' | stats count() as blocked_dest_ip by event.dest_ip as dest_ip\n| filter event.alert.action = 'blocked'\n| sort blocked_dest_ip desc\n| limit 10",
                          "region": "${AWS::Region}",
                          "title": "Top Blocked Destination IPs",
                          "view": "pie"
                      }
                  },
                  {
                      "height": 7,
                      "width": 6,
                      "y": 80,
                      "x": 12,
                      "type": "log",
                      "properties": {
                          "query": "SOURCE '${FirewallAlertLogGroupName}' | stats count() as blocked_dest_port by event.dest_port as dest_port\n| filter event.alert.action = 'blocked'\n| sort blocked_dest_port desc\n| limit 10",
                          "region": "${AWS::Region}",
                          "stacked": false,
                          "title": "Top Blocked Destination Ports",
                          "view": "pie"
                      }
                  },
                  {
                      "height": 7,
                      "width": 6,
                      "y": 80,
                      "x": 18,
                      "type": "metric",
                      "properties": {
                          "period": 60,
                          "region": "${AWS::Region}",
                          "stacked": false,
                          "timezone": "local",
                          "title": "Top Blocked Remote Access Ports - Telnet, SSH, RDP",
                          "view": "timeSeries",
                          "legend": {
                              "position": "right"
                          },
                          "insightRule": {
                              "maxContributorCount": 10,
                              "orderBy": "Sum",
                              "ruleName": "${TopBlockedRemoteAccessPortsRule.RuleName}"
                          }
                      }
                  },
                  {
                      "height": 7,
                      "width": 12,
                      "y": 87,
                      "x": 0,
                      "type": "metric",
                      "properties": {
                          "period": 60,
                          "region": "${AWS::Region}",
                          "stacked": false,
                          "timezone": "local",
                          "title": "Top Blocked TCP Flows",
                          "view": "timeSeries",
                          "legend": {
                              "position": "right"
                          },
                          "insightRule": {
                              "maxContributorCount": 10,
                              "orderBy": "Sum",
                              "ruleName": "${TopBlockedTCPFlowsRule.RuleName}"
                          }
                      }
                  },
                  {
                      "type": "metric",
                      "height": 7,
                      "width": 12,
                      "y": 87,
                      "x": 12,
                      "properties": {
                          "period": 60,
                          "region": "${AWS::Region}",
                          "stacked": false,
                          "timezone": "local",
                          "title": "Top Blocked UDP Flows",
                          "view": "timeSeries",
                          "legend": {
                              "position": "right"
                          },
                          "insightRule": {
                              "maxContributorCount": 10,
                              "orderBy": "Sum",
                              "ruleName": "${TopBlockedUDPFlowsRule.RuleName}"
                          }
                      }
                  },
                  {
                      "height": 1,
                      "width": 24,
                      "y": 94,
                      "x": 0,
                      "type": "text",
                      "properties": {
                          "markdown": "## HTTP & TLS",
                          "background": "transparent"
                      }
                  },
                  {
                      "height": 7,
                      "width": 6,
                      "y": 95,
                      "x": 0,
                      "type": "metric",
                      "properties": {
                          "period": 60,
                          "region": "${AWS::Region}",
                          "stacked": false,
                          "timezone": "local",
                          "title": "Top HTTP Host Header",
                          "view": "timeSeries",
                          "legend": {
                              "position": "right"
                          },
                          "insightRule": {
                              "maxContributorCount": 10,
                              "orderBy": "Sum",
                              "ruleName": "${TopHTTPHostHeaderRule.RuleName}"
                          }
                      }
                  },
                  {
                      "height": 7,
                      "width": 6,
                      "y": 95,
                      "x": 6,
                      "type": "metric",
                      "properties": {
                          "period": 60,
                          "insightRule": {
                              "maxContributorCount": 10,
                              "orderBy": "Sum",
                              "ruleName": "${TopBlockedHTTPHostHeaderRule.RuleName}"
                          },
                          "stacked": false,
                          "view": "timeSeries",
                          "yAxis": {
                              "left": {
                                  "showUnits": false
                              },
                              "right": {
                                  "showUnits": false
                              }
                          },
                          "region": "${AWS::Region}",
                          "title": "Top Blocked HTTP Host Header",
                          "legend": {
                              "position": "right"
                          }
                      }
                  },
                  {
                      "height": 7,
                      "width": 6,
                      "y": 95,
                      "x": 12,
                      "type": "metric",
                      "properties": {
                          "period": 60,
                          "region": "${AWS::Region}",
                          "stacked": false,
                          "timezone": "local",
                          "title": "Top HTTP URI Paths",
                          "view": "timeSeries",
                          "legend": {
                              "position": "right"
                          },
                          "insightRule": {
                              "maxContributorCount": 10,
                              "orderBy": "Sum",
                              "ruleName": "${TopHTTPURIPathsRule.RuleName}"
                          }
                      }
                  },
                  {
                      "height": 7,
                      "width": 6,
                      "y": 95,
                      "x": 18,
                      "type": "metric",
                      "properties": {
                          "period": 60,
                          "region": "${AWS::Region}",
                          "stacked": false,
                          "timezone": "local",
                          "title": "Top HTTP User-Agents",
                          "view": "timeSeries",
                          "legend": {
                              "position": "right"
                          },
                          "insightRule": {
                              "maxContributorCount": 10,
                              "orderBy": "Sum",
                              "ruleName": "${TopHTTPUserAgentsRule.RuleName}"
                          }
                      }
                  },
                  {
                      "height": 7,
                      "width": 6,
                      "y": 102,
                      "x": 0,
                      "type": "metric",
                      "properties": {
                          "period": 60,
                          "region": "${AWS::Region}",
                          "stacked": false,
                          "timezone": "local",
                          "title": "Top TLS SNI",
                          "view": "timeSeries",
                          "legend": {
                              "position": "right"
                          },
                          "insightRule": {
                              "maxContributorCount": 10,
                              "orderBy": "Sum",
                              "ruleName": "${TopTLSSNIRule.RuleName}"
                          }
                      }
                  },
                  {
                      "height": 7,
                      "width": 6,
                      "y": 102,
                      "x": 6,
                      "type": "metric",
                      "properties": {
                          "period": 60,
                          "insightRule": {
                              "maxContributorCount": 10,
                              "orderBy": "Sum",
                              "ruleName": "${TopBlockedTLSSNIRule.RuleName}"
                          },
                          "stacked": false,
                          "view": "timeSeries",
                          "yAxis": {
                              "left": {
                                  "showUnits": false
                              },
                              "right": {
                                  "showUnits": false
                              }
                          },
                          "region": "${AWS::Region}",
                          "title": "Top Blocked TLS SNI",
                          "legend": {
                              "position": "right"
                          }
                      }
                  },
                  {
                      "height": 7,
                      "width": 12,
                      "y": 102,
                      "x": 12,
                      "type": "log",
                      "properties": {
                          "query": "SOURCE '${FirewallAlertLogGroupName}' | stats count(*) as Count by event.src_ip as Source_IP, event.dest_ip as Dest_IP, event.app_proto as App_Proto, event.tls.sni as SNI, event.http.hostname as Hostname\n| filter event.tls.sni like \"s3\" or event.http.hostname like \"s3\" or event.tls.sni like \"dynamodb\" or event.http.hostname like \"dynamodb\" or event.tls.sni like \"backup\" or event.http.hostname like \"backup\"\n| display Source_IP, Dest_IP, App_Proto, SNI, Hostname, Count\n| sort Count desc\n| limit 10",
                          "region": "${AWS::Region}",
                          "title": "Top PrivateLink Endpoint Candidates (S3, DynamoDB, & Backup)",
                          "view": "table"
                      }
                  }    
              ]
          }
        - subnet_query_string: !GetAtt GenerateSubnetQueryStringCustomResource.SubnetQueryString   
      DashboardName: !Sub  ${FirewallName}-dashboard












Outputs:
  DevToProdTesterURL:
    Description: DEV to PROD tester script
    Value: !Sub https://${TestScriptDistribution.DomainName}/dev-to-prod
    Export:
      Name: DevToProdTesterURL

  EgressTesterURL:
    Description: Egress tester script
    Value: !Sub https://${TestScriptDistribution.DomainName}/egress
    Export:
      Name: EgressTesterURL

  OnPremToProdTesterURL:
    Description: OnPrem to PROD tester script
    Value: !Sub https://${TestScriptDistribution.DomainName}/onprem-to-prod
    Export:
      Name: OnPremToProdTesterURL